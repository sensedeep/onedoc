{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"extensions/","title":"Extensions","text":"<p>There is a growing library of tools and extensions that support OneTable.</p> <p>If you have developed a tool or library that uses OneTable, please let us know and we'll add it here.</p>"},{"location":"extensions/#onetable-migrations","title":"OneTable Migrations","text":"<p>To manage your database migrations, use the OneTable Migrate library for inclusion in your services to manage database migrations.</p>"},{"location":"extensions/#onetable-migration-controller","title":"OneTable Migration Controller","text":"<p>The easiest way to get started with OneTable Migrations is to use the OneTable Controller which provides hosting of the OneTable Migration Library.</p>"},{"location":"extensions/#onetable-cli","title":"OneTable CLI","text":"<p>The OneTable CLI which provides command line migration control for the OneTable Migrate library.</p>"},{"location":"extensions/#sensedeep-serverless-developer-studio","title":"SenseDeep Serverless Developer Studio","text":"<p>The SenseDeep Serverless Developer Studio includes a powerful collection of DynamoDB tools with single-table aware data browser, designer, provisioning planner, migration manager and metrics.</p> <p>The SenseDeep studio can be used to create OneTable schemas and to manage DynamoDB tables hosting single-table data.</p>"},{"location":"extensions/#zod-to-onetable","title":"Zod to OneTable","text":"<p>You can sync and integrate existing <code>zod</code> schemas with OneTable by generating whole models or partial model fields using the Zod to OneTable package.</p>"},{"location":"api/errors/","title":"Error Handling","text":"<p>API errors will throw an instance of the <code>OneTableError</code> class. This instance has the following properties:</p> <ul> <li>message \u2014 Text error message.</li> <li>name \u2014 Error class name.</li> <li>code \u2014 Set to the AWS string error code indicating the class of error.</li> <li>context \u2014 Map of additional context information.</li> <li>stack \u2014 Stack backtrace information.</li> </ul> <p>The <code>context</code> contains the original AWS DynamoDB error object as <code>context.err</code>. For transaction errors, the <code>context.err.CancellationReasons</code> holds the specifics of the transaction error.</p>"},{"location":"api/errors/#postformat","title":"PostFormat","text":"<p>In cases where you cannot acheive what you need through the OneTable APIs, you can customize the final request to DynamoDB using <code>postFormat</code>. For a contrived example, imagine if you needed to add an extra ExpressionAttributeValues, you could do:</p> <pre><code>await RouteModel.update({ routeId }, {\nset: { myField: ':myValue' },\npostFormat: (model, args) =&gt; {\nconst extraValues = marshall({ ':myValue': { 'complex': 'Some kind of complex value' } })\nargs.ExpressionAttributeValues = { ...extraValues, ...args.ExpressionAttributeValues }\nreturn args\n}\n})\n</code></pre>"},{"location":"api/dynamo/overview/","title":"Constructor","text":"<p>The Dynamo class is used ease the configuration of the AWS SDK v3. The class is only used with AWS SDK V3 to wrap the DynamoDBClient instance and provide helper methods for OneTable. It does not expose any other methods.</p>"},{"location":"api/dynamo/overview/#dynamo-constructor","title":"Dynamo Constructor","text":"<p>The Dynamo constructor takes a parameter of type <code>object</code> with the following properties:</p> Property Type Description client <code>DynamoDB</code> An AWS SDK v3 DynamoDBClient instance. marshall <code>object</code> Marshall options for converting to DynamoDB attribute types. See: util-dynamodb for details. unmarshall <code>object</code> Unmarshall options for converting from DynamoDB attribute types. See: util-dynamodb for details."},{"location":"api/model/examples/","title":"Examples","text":"<pre><code>import {Table} from 'dynamodb-onetable'\nconst table = new Table({})\nlet Account = table.getModel('Account')\nlet User = table.getModel('User')\n//  Get an item where the name is sufficient to construct the primary key\nlet account = await Account.get({name: 'Acme Airplanes'})\nlet user = await User.get({email: 'user@example.com'}, {index: 'gs1'})\n//  find (query) items\nlet users = await User.find({accountName: 'Acme Airplanes'})\n//  Update an item\nawait User.update({email: 'user@example.com', balance: 0})\n</code></pre>"},{"location":"api/model/methods/","title":"Methods","text":"<p>The <code>Model</code> class represents an entity (item) in the database and is the primary data access API for OneTable.</p> <p>Model APIs take a params parameter that configures and controls the API execution.</p> <p>API errors will throw an instance of the <code>OneTableError</code> error class. See Error Handling for more details.</p>"},{"location":"api/model/methods/#create","title":"create","text":"<pre><code>async create(properties, params = {})\n</code></pre> <p>Create an item in the database. This API wraps the DynamoDB <code>putItem</code> method.</p> <p>The <code>properties</code> parameter is a Javascript hash containing all the required attributes for the item and must contain the required keys or fields that are used to create the primary key.</p> <p>OneTable will only write fields in <code>properties</code> that correspond to the schema attributes for the model. Superfluous property fields will be ignored.</p> <p>The property names are those described by the schema. NOTE: these are not the same as the attribute names stored in the Database. If a schema uses <code>map</code> to define a mapped attribute name, the Javascript field name and the DynamoDB attribute name may be different.</p> <p>The method returns the Javascript properties created for the item. Hidden attributes will not be returned.</p> <p>Before creating the item, all the properties will be validated according to any defined schema validations and all required properties will be checked. Similarly, properties that use a schema enum definition will be checked that their value is a valid enum value. Encrypted fields will be encrypted transparently before writing.</p> <p>For create, the params.exists will default to a false value to ensure an item of the same key does not already exist. If set to null, a create will be allowed to overwrite an existing item.</p>"},{"location":"api/model/methods/#unique-fields","title":"Unique Fields","text":"<p>If the schema specifies that an attribute must be unique, OneTable will create a special item in the database to enforce the uniqueness. This item will be an instance of the Unique model with the primary key set to <code>_unique#Scope#Model#Attribute#Value</code>. The created item and the unique item will be created in a transparent transaction so that the item will be created only if all the unique fields are truly unique.  The <code>remove</code> API will similarly remove the special unique item.</p> <p>A property may be be unique with a defined domain via the \"scope\" model schema property. The scope template will be expanded at runtime and the scope value will be incorporated into the unique attribute. This is useful to ensure an attribute is unique within a reduced domain. For example, you may want an item to be unique only within a given user's account instead of over all accounts. To achieve this, set the scope to be the user's ID.</p> <p>When a unique field for an item is updated, the prior item value must be read first so that the unique item can be deleted. By default, updates() on an item with unique fields will not return a value and will issue a warning to the console. This is because DynamoDB transactions do not return the updated items. If you do an update and specify {return: 'NONE'} the warning will be squelched. If you must return the full updated item, use {return: 'get'} to fetch the updated values.</p> <p>The optional params are described in Model API Params.</p> <p></p>"},{"location":"api/model/methods/#find","title":"find","text":"<pre><code>async find(properties, params = {})\n</code></pre> <p>Find items in the database. This API wraps the DynamoDB <code>query</code> method.</p> <p>The <code>properties</code> parameter is a Javascript hash containing the required keys or fields that are used to determine the primary key or keys. </p> <p>When using value templates for key fields, it is preferable to use non-key properties and rely on OneTable to compute the key fields.</p> <p>If provided, the sort key may be defined as a simple value or as a key condition by setting the property to an object that defines the condition. The condition operator is specified as the key, and the operand as the value. For example:</p> <pre><code>let user = await User.find({pk, sk: {begins: 'user:john'}})\nlet tickets = await Ticket.find({pk, sk: {between: [1000, 2000]}})\nlet invoices = await Invoice.find({pk, sk: {'&lt;=': 1000}})\nlet invoices = await Invoice.find({pk}, {where: '${sk} &lt;= {1000}'})\nlet items = await Invoice.find({pk}, {where: '${sk} &lt;= {1000}'}, {count: true})\nlet count = items.count\n</code></pre> <p>The operators include:</p> <pre><code>&lt; &lt;= = &gt;= &gt;\nbegins or begins_with\nbetween\n</code></pre> <p>Additional fields supplied in <code>properties</code> are used to construct a filter expression which is applied by DynamoDB after reading the data but before returning it to the caller. OneTable will utilize fields in <code>properties</code> that correspond to the schema attributes for the model. Superfluous property fields will be ignored in the filter expression.</p> <p>More complex filter expressions may be created via a <code>params.where</code> property. For example:</p> <pre><code>let adminUsers = await User.find({}, {\nwhere: '(${role} = {admin}) and (${status} = {current})'\n})\n</code></pre> <p>Use <code>params.count</code> set to true to return the number of matching items instead of returning the items.</p> <p>See Where Clause for more details.</p> <p>If <code>find</code> is called without a sort key on a model that has a sort key value template, OneTable will synthesize a sort key value using the leading portion of the sort key value template. For example, if the sort key is defined as:</p> <pre><code>Card: {\nsk: { type: String, value: 'card#${id}' }\n}\n</code></pre> <p>then, OneTable will use a <code>begins_with card:</code> key condition expression. This will also work if you use <code>${_type}</code> as the leading prefix.</p> <p>Without the ingredient properties needed calculate the sort key from its value template, <code>find</code> will synthesize a sort key using the leading portion utilize the model type as a sort key prefix and return all matching model items. This can be used to fetch all items that match the primary hash key and are of the specified model type.</p> <p>The <code>find</code> method returns an array of items after applying any schema mappings. Hidden attributes in items will not be returned.</p>"},{"location":"api/model/methods/#pagination","title":"Pagination","text":"<p>The <code>find</code> method will automatically invoke DynamoDB query to fetch additional items and aggregate the result up to the limit specified by <code>params.limit</code>. If the limit is exceeded, the last key fetched is set in the result.next property of the returned array of items. You can provide this as <code>params.next</code> to a subsequent API call to continue the query with the next page of results.</p> <pre><code>let next\ndo {\nlet items = await User.find({accountId}, {limit: 10, next})\n//  process items\nnext = items.next\n} while (next)\n</code></pre> <p>To scan backwards, set Params.reverse to true.</p> <p>The keys for the first item are returned in <code>params.prev</code> which can be used to retrieve the previous page.</p> <pre><code>let firstPage = await User.find({accountId}, {limit})\nlet secondPage = await User.find({accountId}, {limit, next: firstPage.next})\nlet previousPage = await User.find({accountId}, {limit, prev: secondPage.prev})\n</code></pre> <p>Note: the limit is the number of items read by DynamoDB before filtering and thus may not be equal to the number of items returned if you are using filtering expressions.</p> <p>The optional params are fully described in Model API Params. Some relevant params include:</p> <p>If <code>params.execute</code> is set to false, the command will not be executed and the prepared DynamoDB API parameters will be returned. However, if set on an update that has a unique field, the commands will not be returned. This is because and update with a unique field requires a transaction and multiple commands. In this case, setting execute: true will cause the command to not be executed as expected, but the the proposed commands will not be returned. To see the commands, set the parmas.log to true to log the commands to the console.</p> <p>The <code>params.fields</code> may be set to a list of properties to return. This defines the ProjectionExpression.</p> <p>If the <code>params.follow</code> is set to true, each item will be re-fetched using the returned results. This is useful for KEYS_ONLY secondary indexes where OneTable will use the retrieved keys to fetch all the attributes of the entire item using the primary index. This incurs an additional request for each item, but for large data sets, it enables the transparent use of a KEYS_ONLY secondary index which may greatly reduce the size (and cost) of the secondary index.</p> <p>The <code>params.limit</code> specifies the maximum number of items for DynamoDB to read. The <code>params.next</code> defines the start point for the returned items. It is typically set to the last key returned from previous invocation via the <code>result.next</code> property. Note: the limit is the number of items DynamoDB reads before filtering.</p> <p>The <code>params.maxPages</code> specifies the maximum number of DynamoDB query requests that OneTable will perform for a single API request. When doing a find or query with a filter expression, DynamoDB may scan up to 1MB and may return no items. Find will re-issue the API following the next key to retrieve the set of results. A maxPages limit will define the maximum number of times Find will query DynamoDB for another chunk of results.</p> <p>If <code>params.parse</code> is set to false, the unmodified DynamoDB response will be returned. Otherwise the results will be parsed and mapped into a set of Javascript properties.</p> <p>If <code>params.next</code> or <code>params.prev</code> is set to a map that contains the primary hash and sort key values for an existing item, the query will commence at that item. The <code>params.next</code> will be the exclusive start of the query, whereas <code>params.prev</code> will define the end of the query. These two properties are mutually exclusive, both of them can't be set at the same time.</p> <p>The <code>params.where</code> clause may be used to augment the filter expression. This will define a FilterExpression and the ExpressionAttributeNames and ExpressionAttributeValues. See Where Clause for more details.</p> <p></p>"},{"location":"api/model/methods/#get","title":"get","text":"<pre><code>async get(properties, params = {})\n</code></pre> <p>Get an item from the database. This API wraps the DynamoDB <code>getItem</code> method.</p> <p>The <code>properties</code> parameter is a Javascript hash containing the required keys or fields that are used to create the primary key.</p> <p>When using value templates for key fields, it is preferable to use non-key properties and rely on OneTable to compute the key fields.</p> <p>Additional fields supplied in <code>properties</code> may be used to construct a filter expression. In this case, a <code>find</code> query is first executed to identify the item to retrieve. Superfluous property fields will be ignored.</p> <p>The <code>get</code> method returns Javascript properties for the item after applying any schema mappings. Hidden attributes will not be returned.</p> <p>The optional params are fully described in Model API Params. Some relevant params include:</p> <p>The <code>params.fields</code> may be set to a list of properties to return. This defines the ProjectionExpression.</p> <p>If the <code>params.follow</code> is set to true, the item will be re-fetched using the retrieved keys for the item. This is useful for KEYS_ONLY secondary indexes where OneTable will use the retrieved keys to fetch all the attributes of the item using the primary index. This incurs an additional request, but for very large data sets, it enables the transparent use of a KEYS_ONLY secondary index which reduces the size of the database.</p> <p>If <code>params.execute</code> is set to false, the command will not be executed and the prepared DynamoDB API parameters will be returned.</p> <p>If <code>params.parse</code> is set to false, the unmodified DynamoDB response will be returned. Otherwise the results will be parsed and mapped into a set of Javascript properties.</p> <p>The <code>params.where</code> clause may be used to define a filter expression. This will define a FilterExpression and the ExpressionAttributeNames and ExpressionAttributeValues. See Where Clause for more details.</p> <p></p>"},{"location":"api/model/methods/#init","title":"init","text":"<pre><code>async init(properties, params = {})\n</code></pre> <p>Return a constructed model item without writing to the database. This will return an object with all the model properties set to null including default properties, UUID properties and value template properties. Be careful using these objects with create() as you should define values for all attributes.</p> <p></p>"},{"location":"api/model/methods/#remove","title":"remove","text":"<pre><code>async remove(properties, params = {})\n</code></pre> <p>Remove an item from the database. This wraps the DynamoDB <code>deleteItem</code> method.</p> <p>The <code>properties</code> parameter is a Javascript hash containing the required keys or fields that are used to create the primary key.</p> <p>Additional fields supplied in <code>properties</code> may be used to construct a filter expression. In this case, a <code>find</code> query is first executed to identify the item to remove. Superfluous property fields will be ignored.</p> <p>The optional params are fully described in Model API Params. Some relevant params include:</p> <p>The <code>params.fields</code> may be set to a list of properties to return. This defines the ProjectionExpression.</p> <p>If <code>params.execute</code> is set to false, the command will not be executed and the prepared DynamoDB API parameters will be returned.</p> <p>If <code>params.many</code> is set to true, the API may be used to delete more than one item. Otherwise, for safety, it is assume the API will only remove one item.</p> <p>The <code>params.where</code> clause may be used to define a filter expression. This will define a FilterExpression and the ExpressionAttributeNames and ExpressionAttributeValues. See Where Clause for more details.</p> <p>This API does not return a result. To test if the item was actually removed, set <code>params.exists</code> to true and the API will throw an exception if the item does not exist.</p> <p></p>"},{"location":"api/model/methods/#scan","title":"scan","text":"<pre><code>async scan(properties, params = {})\n</code></pre> <p>Scan items in the database and return items of the given model type. This wraps the DynamoDB <code>scan</code> method and uses a filter expression to extract the designated model type. Use <code>scanItems</code> to return all model types. NOTE: this will still scan the entire database.</p> <p>An alternative to using scan to retrieve all items of a give model type is to create a GSI and index the model <code>type</code> field and then use <code>query</code> to retrieve the items. This index can be a sparse index if only a subset of models are indexed.</p> <p>The <code>properties</code> parameter is a Javascript hash containing fields used to construct a filter expression which is applied by DynamoDB after reading the data but before returning it to the caller. OneTable will utilize fields in <code>properties</code> that correspond to the schema attributes for the model. Superfluous property fields will be ignored in the filter expression.</p> <p>The <code>scan</code> method returns an array of items after applying any schema mappings. Hidden attributes in items will not be returned.</p> <p>The optional params are fully described in Model API Params. Some relevant params include:</p> <p>The <code>params.fields</code> may be set to a list of properties to return. This defines the ProjectionExpression.</p> <p>If <code>params.execute</code> is set to false, the command will not be executed and the prepared DynamoDB API parameters will be returned.</p> <p>The <code>params.where</code> clause may be used to augment the filter expression. This will define a FilterExpression and the ExpressionAttributeNames and ExpressionAttributeValues. See Where Clause for more details.</p> <p>The scan method supports parallel scan where you invoke scan simultaneously from multiple workers. Using the async/await pattern, you can start the workers and then use a Promise.all to wait for their completion. To perform parallel scans, you should set the <code>params.segments</code> to the number of parallel segements and the <code>params.segment</code> to the numeric segment to be scaned for that worker.</p> <pre><code>const segments = 4\nlet promises = []\nfor (let segment = 0; segment &lt; segments; segment++) {\n    promises.push(table.scan({}, {segment, segments}))\n}\nlet results = await Promise.all(promises)\n</code></pre> <p></p>"},{"location":"api/model/methods/#template","title":"template","text":"<pre><code>async template(fieldName, properties)\n</code></pre> <p>Return the evaluated field value template based on the given properties. This is a utility routine to manually evaluate value templates.</p> <p></p>"},{"location":"api/model/methods/#update","title":"update","text":"<pre><code>async update(properties, params = {})\n</code></pre> <p>Update an item in the database. This method wraps the DynamoDB <code>updateItem</code> API.</p> <p>The <code>properties</code> parameter is a Javascript hash containing properties to update including the required keys or fields that are used to create the primary key.</p> <p>OneTable will only update fields in <code>properties</code> that correspond to the schema attributes for the model. Superfluous property fields will be ignored.</p> <p>The property names are those described by the schema. NOTE: these are not the same as the attribute names stored in the Database. If a schema uses <code>map</code> to define a mapped attribute name, the Javascript field name and the DynamoDB attribute name may be different.</p> <p>The method returns the all the Javascript properties for the item. Hidden attributes will not be returned.</p> <p>If the method fails to update, it will throw an exception. If <code>params.throw</code> is set to false, an exception will not be thrown and the method will return <code>undefined</code>.</p> <p>The optional params are described in Model API Params.    </p> <p>The <code>params.add</code> parameter may be set to a value to add to the property. The <code>params.delete</code> parameter may be set to a hash, where the hash keys are the property sets to modify and the values are the items in the sets to remove. The <code>params.remove</code> parameter may be set to a list of properties to remove. The <code>params.set</code> parameter may be set to a hash, where the hash keys are the properties to modify and the values are expresions.</p> <p>The <code>params.return</code> parameter may be set to 'NONE' to return no result or 'get' to perform a transparent get() call to retrieve the updated item. Normally, update() will return the updated item automatically, however, it the item has unique attributes, a transaction is used which does not return the updated item. In this case, use {return: 'get'} to retrieve and return the updated item.</p> <p>The propertys provided to params.add, delete, remove and set are property names (not mapped attribute names).</p> <p>If a property is specified in the API <code>properties</code> first argument and the property is also set in params.set, params.delete, params.remove or params.add, then the params.* property value takes precedence.</p> <p>For example:</p> <pre><code>await User.update({id: userId}, {delete: {tokens: ['captain']}})\nawait User.update({id: userId}, {remove: ['special', 'suspended']})\nawait User.update({id: userId}, {set: {balance: '${balance} + {100}'}})\nawait User.update({id: userId}, {\nset: {contacts: 'list_append(if_not_exists(contacts, @{empty_list}), @{newContacts})'},\nsubstitutions: {newContacts: ['+15555555555'], empty_list: []}\n})\n</code></pre> <p>In update, the params.exists will default to a true value to ensure the item exists. If set to null, an update will be permitted to create an item if it does not already exist. This implements an \"upsert\" operation.</p> <p>In this case, you must provide values for all properties that are required for a create.</p>"},{"location":"api/model/overview/","title":"Overview","text":"<p>The <code>Model</code> class represents an application entity that is modeled according to your OneTable schema. With one-table design patterns, multiple entities items are stored in a single DynamoDB table and are distinguished by unique primary keys and a <code>type</code> attribute that designates the model type. The schema specifies the entity attributes and keys and the Model instance is the mechanism by which you interact with specific entities in your table.</p> <p>Models are defined via the Table <code>schema</code> definition and model instances are created using the Table.getModel(name) method.</p> <pre><code>let User = table.getModel('User')\n</code></pre> <p>Where <code>table</code> is a configured instance of <code>Table</code>. Name is the name of the model.</p> <p>In TypeScript, use the following pattern to return a fully typed model:</p> <pre><code>type UserType = Entity&lt;typeof Schema.models.User&gt;\nlet User = table.getModel&lt;UserType&gt;('User')\n</code></pre> <p>Thereafter, the references to User instances will be fully type checked. Note: you must add \"as const\" to the end of your models after the closing brace.</p>"},{"location":"api/model/overview/#model-constructor","title":"Model Constructor","text":"<p>The model constructor is an internal method and you should not normally construct model instances directly.</p> <p>The Model constructor <code>options</code> are:</p> Property Type Description fields <code>object</code> Field attribute definitions. Same format as in the Table <code>schema</code> indexes <code>object</code> Index definition. Same format as in the Table <code>schema</code> timestamps <code>boolean</code> Make \"created\" and \"updated\" timestamps in items"},{"location":"api/model/params/","title":"API Parameters","text":"<p>Most <code>Model</code> APIs and some <code>Table</code> APIs accept a <code>params</code> hash argument that controls the API operation.</p>"},{"location":"api/model/params/#params","title":"Params","text":"<p>These are the parameter values for the <code>params</code> argument.</p> Property Type Description add <code>object</code> Used to atomically add a value to an attribute. Set to an object containing the attribute name and value to add. Example: add: batch <code>object</code> Accumulated batched API calls. Invoke with <code>Table.batch*</code> capacity <code>string</code> Set to <code>INDEXES</code>, <code>TOTAL</code>  or <code>NONE</code> to control the capacity metric. Returned in items.capacity client <code>object</code> Set to a DynamoDB DocumentClient instance to overide the table default client. Defaults to null consistent <code>boolean</code> Set to true to stipulate that consistent reads are required. context <code>object</code> Optional context hash of properties to blend with API properties when creating or updating items. This overrides the Table.context. Setting to <code>{}</code> is a useful one-off way to ignore the context for this API. count <code>boolean</code> Return a count of matching items instead of the result set for a find/query. The count is returned as a <code>count</code> property in the returned items array. Default false. delete <code>object</code> Used to delete items from a <code>set</code> attribute. Set to an object containing the attribute name and item to delete. Example: delete: execute <code>boolean</code> Set to true to execute the API. If false, return the formatted command and do not execute. Note: if set on an update of a unique field which requires a transaction and multiple commands, the commands will not be returned. To see the commands, set the parmas.log to true. Execute defaults to true. exists <code>boolean</code> Set to true for <code>create</code>, <code>delete</code> or <code>update</code> APIs to verify if an item of the same key exists or not. Defaults to false for <code>create</code>, null for <code>delete</code> and true for <code>update</code> Set to null to disable checking either way. fields <code>array</code> List of properties to return. This sets the ProjectionExpression. Default null. follow <code>boolean</code> Refetch the item using the returned keys to retrieve the full item. Useful for indexes that are KEYS_ONLY. Default null. hidden <code>boolean</code> Return hidden attributes in Javascript properties. Default Table params.hidden. index <code>string</code> Name of index to utilize. Defaults to 'primary' limit <code>number</code> Set to the maximum number of items to return from a find / scan. log <code>boolean</code> Set to true to force the API call to be logged at the 'data' level. Requires that a 'logger' be defined via the Table constructor. Defaults to false. many <code>boolean</code> Set to true to enable deleting multiple items. Default to false. noerror <code>boolean</code> Sto to true to suppress some logginer errors. Defaults to false. next <code>object</code> Starting key for the result set. This is used to set the ExclusiveStartKey when doing a find/scan. Typically set to the result.next value returned on a previous find/scan. prev <code>object</code> Starting key for the result set when requesting a previous page. This is used to set the ExclusiveStartKey when doing a find/scan in reverse order. Typically set to the result.prev value returned on a previous find/scan. parse <code>boolean</code> Parse DynamoDB response into native Javascript properties. Defaults to true. partial <code>boolean</code> Allow partial object updates for this API call. This overrides any field schema, or Table constructor \"partial\" definitions. Default is null. postFormat <code>function</code> Hook to invoke on the formatted API command just before execution. Passed the <code>model</code> and <code>cmd</code>, expects updated <code>cmd</code> to be returned. Cmd is an object with properties for the relevant DynamoDB API. remove <code>array</code> Set to a list of of attributes to remove from the item. reprocess <code>boolean</code> Set to true to enable batchWrite to retry unprocessed items. Defaults to true return string Controls the returned values for create() and update() via the ReturnValues DynamoDB API parameter. Set to true, false or 'ALL_NEW', 'ALL_OLD', 'NONE', 'UPDATED_OLD' or 'UPDATED_NEW'. The value true, is an alias for ALL_NEW. The value false is an alias for 'NONE'. The create() API defaults to 'ALL_NEW'. The update() API defaults to 'ALL_NEW' unless the item has unique properties the return parameter must be specified. For update() calls on items that have unique attributes defined in the schema, you can set to 'get' to perform a transparent get() to retrieve the updated item. This is necessary as updating unique items uses transactions which do not return the updated value. reverse <code>boolean</code> Set to true to reverse the order of items returned. select <code>string</code> Determine the returned attributes. Set to ALL_ATTRIBUTES set <code>object</code> Used to atomically set attribute vaules to an expression value. Set to an object containing the attribute names and values to assign. The values are expressions similar to Where Clauses with embedded ${attributeReferences} and {values}. See Where Clause for more details. stats <code>object</code> Set to an object to receive performance statistics for find/scan. Defaults to null. substitutions <code>object</code> Variables that can be referenced in a where clause. Values will be added to ExpressionAttributeValues when used. throw <code>boolean</code> Set to false to not throw exceptions when an API request fails. Defaults to true. transaction <code>object</code> Accumulated transactional API calls. Invoke with <code>Table.transaction</code> type <code>string</code> Add a <code>type</code> condition to the <code>create</code>, <code>delete</code> or <code>update</code> API call. Set <code>type</code> to the DynamoDB required type. where <code>string</code> Define a filter or update conditional expression template. Use <code>${attribute}</code> for attribute names, <code>@{var}</code> for variable substitutions and <code>{value}</code> for values. OneTable will extract attributes and values into the relevant ExpressionAttributeNames and ExpressionAttributeValues."},{"location":"api/model/params/#stats","title":"Stats","text":"<p>If <code>stats</code> is defined, find/query/scan operations will return the following statistics in the stats object:</p> <ul> <li>count -- Number of items returned</li> <li>scanned -- Number of items scanned</li> <li>capacity -- DynamoDB consumed capacity units</li> </ul>"},{"location":"api/model/params/#transformations","title":"Transformations","text":"<p>The <code>transform</code> property may be used to format data prior to writing into the database and parse it when reading back. This can be useful to convert to alternate data representations in your table. The transform signature is:</p> <pre><code>value = transform(model, operation, name, value, properties)\n</code></pre> <p>The <code>operation</code> parameter is set to <code>read</code> or <code>write</code>. The <code>name</code> argument is set to the field attribute name.</p>"},{"location":"api/model/set/","title":"Set Expressions","text":"<p>OneTable <code>set</code> expressions are a powerful way to express DynamoDB update expressions. DynamoDB ExpressionAttributeNames and Values are one of the least fun parts of DynamoDB. OneTable makes this much easier via the use of templated <code>set</code> clauses to express complex update expressions.</p> <p>A <code>set</code> clause may be used with the <code>update</code> API to specify an Update expression. OneTable will parse the <code>set</code> clause and extract the names and values to use with the DynamoDB API.</p> <p>For example:</p> <pre><code>const schema = {\nversion: '0.0.1',\nindexes: {\nprimary: {hash: 'pk', sort: 'sk'},\n},\nmodels: {\nUser: {\npk: { type: String, value: '${_type}#' },\nsk: { type: String, value: '${_type}#${email}' },\nemail: { type: String, required: true },\naddresses: { type: Array, default: [] }\n}\n} as const,\n}\n//  Create a user without an address\nlet users = await User.create({email: 'user@example.com'}\n//  Set the first address\nlet user = await User.update({email: 'user@example.com'}, {\nset: {'address[0]': '1212 Cherry Tree Lane'},\n})\n//  Append further addresses\nuser = await User.update({email: user.email}, {\nset: {addresses: 'list_append(addresses, @{newAddress})'},\nsubstitutions: {\nnewAddress: ['25 Mayfair cresent']\n}\n})\n</code></pre> <p>OneTable will extract property names defined inside <code>${}</code> braces, variable substitutions in <code>@{}</code> braces and values inside <code>{}</code> braces and will automatically define your update expression and the required ExpressionAttributeNames and ExpressionAttributeValues.</p> <p>If a value inside <code>{}</code> is a number, it will be typed as a number for DynamoDB. To force a value to be treated as a string, wrap it in quotes, for example: <code>{\"42\"}</code>.</p> <p>Note: the property name is an unmapped schema property name and not a mapped attribute name.</p> <p>The use of <code>@{}</code> substitutions is required when using <code>list_append</code>.</p> <p>See also Where Clauses for using Filter Expressions with similar syntax.</p> <p>See the AWS Update Expression Reference for more details.</p>"},{"location":"api/model/where/","title":"Where Clauses","text":"<p>OneTable <code>where</code> clauses are a convenient way to express DynamoDB filter expressions. DynamoDB ExpressionAttributeNames and Values are one of the least fun parts of DynamoDB. OneTable makes this much easier via the use of templated <code>where</code> clauses to express complex filter expressions.</p> <p>A <code>where</code> clause may be used with <code>find</code>, <code>scan</code>, <code>create</code>, <code>delete</code> or <code>update</code> APIs to specify a Filter or Conditional update expression. OneTable will parse the <code>where</code> clause and extract the names and values to use with the DynamoDB API.</p> <p>For example:</p> <pre><code>let adminUsers = await User.find({}, {\nwhere: '(${role} = {admin}) and (${status} = @{status})',\nsubstitutions: {\nstatus: 'current'\n}\n})\n</code></pre> <p>OneTable will extract property names defined inside <code>${}</code> braces, variable substitutions in <code>@{}</code> braces and values inside <code>{}</code> braces and will automatically define your filter or conditional expressions and the required ExpressionAttributeNames and ExpressionAttributeValues.</p> <p>If a value inside <code>{}</code> is a number, it will be typed as a number for DynamoDB. To force a value to be treated as a string, wrap it in quotes, for example: <code>{\"42\"}</code>.</p> <p>Note: the property name is an unmapped schema property name and not a mapped attribute name.</p> <p>Substitutions also support a <code>splat</code> syntax for use with filterExpressions and the <code>IN</code> operator.</p> <p>With this syntax, the list is expanded in-situ and each list item is defined as a separate ExpressionAttributeValue.</p> <pre><code>let adminUsers = await User.find({}, {\nwhere: '(${role} IN (@{...roles}))',\nsubstitutions: {\nroles: ['user', 'admin']\n}\n})\n</code></pre>"},{"location":"api/model/where/#where-clause-operators","title":"Where Clause Operators","text":"<p>You can use the following operators with a <code>where</code> clause:</p> <ul> <li>&lt; &lt;= = &lt;&gt; &gt;= &gt;</li> <li>AND OR NOT BETWEEN IN</li> <li>()</li> <li>attribute_exists()</li> <li>attribute_not_exists()</li> <li>attribute_type()</li> <li>begins_with()</li> <li>contains()</li> <li>not_contains()</li> <li>size</li> </ul> <p>Note that equals is a single \"=\" and not equals is \"&lt;&gt;\".</p> <p>Where clauses when used with <code>find</code> or <code>scan</code> on non-key attributes can also use the <code>&lt;&gt;</code> not equals operator.</p> <p>See the AWS Comparison Expression Reference for more details.</p>"},{"location":"api/table/contexts/","title":"Contexts","text":"<p>Each <code>Table</code> has a <code>context</code> of properties that are blended with <code>Model</code> properties before executing APIs. The context is used to provide keys and attributes that apply to more than just one API invocation. A typical use case is for a central authorization module to add an <code>accountId</code> or <code>userId</code> to the context which is then used in keys for items belonging to that account or user. This is useful for multi-tenant applications.</p> <p>When creating items, context properties are written to the database. When updating, context properties are not, only explicit attributes provided in the API <code>properties</code> parameter are written.</p> <p>Context properties take precedence over supplied <code>properties</code>. This is to prevent accidental updating of context keys. To force an update of context attributes, provide the context properties either by updating the context via <code>Table.addContext</code>, replacing the context via <code>Table.setContext</code> or supplying an explicit context via <code>params.context</code> to the individual API.</p> <p>Use the <code>Table.setContext</code> method to initialize the context and <code>Table.clear</code> to reset.</p> <p>For example:</p> <pre><code>table.setContext({\nuserId: 'user-42'\n})\n</code></pre>"},{"location":"api/table/examples/","title":"Examples","text":"<p>Here are a few examples using the Table API. For most data accesses, the Model API is used.</p>"},{"location":"api/table/examples/#setup","title":"Setup","text":"<pre><code>import {Table} from 'dynamodb-onetable'\nconst table = new Table({\nclient: DocumentClientInstance,\nname: 'MyTable',\nschema: Schema,\n})\n</code></pre>"},{"location":"api/table/examples/#fetch-an-item-collection","title":"Fetch an Item Collection","text":"<pre><code>let items = await table.fetch(['User', 'Product'], {pk: 'account:AcmeCorp'})\nlet users = items.User\nlet products = items.Product\n</code></pre>"},{"location":"api/table/examples/#query-items-and-then-group-by-type","title":"Query Items and then Group by Type","text":"<pre><code>let items = await table.queryItems({pk: 'account:AcmeCorp'}, {parse: true, hidden: true})\nitems = table.groupByType(items)\nlet users = items.User\nlet products = items.Product\n</code></pre>"},{"location":"api/table/examples/#get-item","title":"Get Item","text":"<pre><code>//  Fetch an account by the ID which is used to create the primary key value\nlet account = await table.get('Account', {id})\n</code></pre>"},{"location":"api/table/examples/#transactional-update","title":"Transactional Update","text":"<pre><code>let transaction = {}\nawait table.update('Account', {id: account.id, status: 'active'}, {transaction})\nawait table.update('User', {id: user.id, role: 'user'}, {transaction})\nawait table.transact('write', transaction)\n</code></pre>"},{"location":"api/table/examples/#scan","title":"Scan","text":"<pre><code>//  Get the number of accounts without reading the items\nlet accounts = await table.scan('Account')\nlet count = accounts.count\n</code></pre>"},{"location":"api/table/methods/","title":"Methods","text":"<p>The Table API provides utility methods and low-level data API to manage DynamoDB. The low-level methods are: deleteItem, getItem, putItem, updateItem. Use these methods to do raw I/O on your table. In general, you should prefer the Model APIs that are based on their schema definition and provide a higher level of operation. The model methods are: create, get, find, remove and update.</p>"},{"location":"api/table/methods/#addcontext","title":"addContext","text":"<pre><code>addContext(context = {})\n</code></pre> <p>Add the table <code>context</code> properties. The context properties are merged with (overwrite) the existing context.</p>"},{"location":"api/table/methods/#addmodel","title":"addModel","text":"<pre><code>addModel(name, fields)\n</code></pre> <p>Add a new model to a table. This invokes the <code>Model</code> constructor and then adds the model to the table. The previously defined <code>Table</code> indexes are used for the model.</p>"},{"location":"api/table/methods/#batchget","title":"batchGet","text":"<pre><code>async batchGet(operation, params = {})\n</code></pre> <p>Invoke a prepared batch operation and return the results. Batches are prepared by creating a bare batch object <code>{}</code> and passing that via <code>params.batch</code> to the various OneTable APIs to build up a batched operation. Invoking <code>batch</code> will execute the accumulated API calls in a batch.</p> <p>The <code>batch</code> parameter should initially be set to <code>{}</code> and then be passed to API calls via <code>params.batch</code>.</p> <p>For example:</p> <pre><code>let batch = {}\nawait Account.get({id: accountId}, {batch})\nawait User.get({id: userId}, {batch})\nlet results = await table.batchGet(batch)\n</code></pre> <p>Set batch params.consistent for a consistent read.</p> <p>If using params.fields to return a field set, you must provide actual attribute names in the field list and not mapped property names like when using normal Model params.fields.</p>"},{"location":"api/table/methods/#batchwrite","title":"batchWrite","text":"<pre><code>async batchWrite(batch, params = {})\n</code></pre> <p>Same as batchGet but for write operations.</p>"},{"location":"api/table/methods/#clearcontext","title":"clearContext","text":"<pre><code>clearContext()\n</code></pre> <p>Clear the table context properties. The <code>Table</code> has a <code>context</code> of properties that are blended with <code>Model</code> properties before writing items to the database.</p>"},{"location":"api/table/methods/#create","title":"create","text":"<pre><code>async create(modelName, properties, params = {})\n</code></pre> <p>Create a new item in the database of the given model <code>modelName</code> as defined in the table schema. Wraps the <code>Model.create</code> API. See Model.create for details.</p>"},{"location":"api/table/methods/#createtable","title":"createTable","text":"<pre><code>async createTable(params)\n</code></pre> <p>Create a DynamoDB table based upon the needs of the specified OneTable schema. The table configuration can be augmented by supplying additional createTable configuration via the <code>params.provisioned</code>. See DynamoDB CreateTable for details.</p>"},{"location":"api/table/methods/#deleteitem","title":"deleteItem","text":"<pre><code>async deleteItem(properties, params = {})\n</code></pre> <p>Delete an item in the database. This wraps the DynamoDB <code>deleteItem</code> method.</p> <p>The <code>properties</code> parameter is a Javascript hash containing the required keys or fields that are used to create the primary key.</p> <p>Additional fields supplied in <code>properties</code> may be used to construct a filter expression. In this case, a <code>find</code> query is first executed to identify the item to remove. Superfluous property fields will be ignored.</p> <p>The optional params are fully described in Model API Params. Some relevant params include:</p> <p>The <code>params.fields</code> may be set to a list of properties to return. This defines the ProjectionExpression. The properties must include the key attributes if you wish to use <code>params.prev</code> for reverse pagination.</p> <p>If <code>params.execute</code> is set to false, the command will not be executed and the prepared DynamoDB API parameters will be returned.</p> <p>If <code>params.many</code> is set to true, the API may be used to delete more than one item. Otherwise, for safety, it is assume the API will only remove one item.</p> <p>The <code>params.where</code> clause may be used to define a filter expression. This will define a FilterExpression and the ExpressionAttributeNames and ExpressionAttributeValues. See Where Clause for more details.</p>"},{"location":"api/table/methods/#deletetable","title":"deleteTable","text":"<pre><code>async deleteTable(confirmation)\n</code></pre> <p>Delete a DynamoDB table. Because this is a destructive operation, a confirmation string of 'DeleteTableForever' must be provided.</p>"},{"location":"api/table/methods/#exists","title":"exists","text":"<pre><code>async exists()\n</code></pre> <p>Test if the table name exists in the database.</p>"},{"location":"api/table/methods/#fetch","title":"fetch","text":"<pre><code>async fetch(models, properties, params = {})\n</code></pre> <p>Fetch an item collection of items that share the same primary key. Models should be a list of model type names to return. The properties should provide the primary key shared by those model types. The return result is a map with items organized by their model type.</p> <p>For example:</p> <pre><code>let items = await table.fetch(['User', 'Product'], {pk: 'account:AcmeCorp'})\nlet users = items.User\nlet products = items.Product\nusers.forEach(user =&gt; /* operate on user */)\nproducts.forEach(product =&gt; /* operate on product */)\n</code></pre> <p>The results returned will include hidden properties as they are needed to group the items by type.</p>"},{"location":"api/table/methods/#find","title":"find","text":"<pre><code>async find(modelName, properties, params = {})\n</code></pre> <p>Find an item in the database of the given model <code>modelName</code> as defined in the table schema. Wraps the <code>Model.find</code> API. See Model.find for details.</p>"},{"location":"api/table/methods/#get","title":"get","text":"<pre><code>async get(modelName, properties, params = {})\n</code></pre> <p>Get an item in the database of the given model <code>modelName</code> as defined in the table schema. Wraps the <code>Model.get</code> API. See Model.get for details.</p>"},{"location":"api/table/methods/#getcontext","title":"getContext","text":"<pre><code>getContext()\n</code></pre> <p>Return the current context properties.</p>"},{"location":"api/table/methods/#getcurrentschema","title":"getCurrentSchema","text":"<pre><code>getCurrentSchema(): OneSchema\n</code></pre> <p>Return the schema currently used by the table.</p>"},{"location":"api/table/methods/#getlog","title":"getLog","text":"<pre><code>getLog()\n</code></pre> <p>Return the current logger object.</p>"},{"location":"api/table/methods/#getkeys","title":"getKeys","text":"<pre><code>async getKeys()\n</code></pre> <p>Return the current primary table and global secondary index keys. Returns a map indexed by index name or 'primary'. The partition key property is named 'hash' and the sort key 'sort'.</p>"},{"location":"api/table/methods/#getitem","title":"getItem","text":"<pre><code>async getItem(properties, params = {})\n</code></pre> <p>Get an item from the database. This API wraps the DynamoDB <code>getItem</code> method.</p> <p>The <code>properties</code> parameter is a Javascript hash containing the required keys or fields that are used to create the primary key.</p> <p>Additional fields supplied in <code>properties</code> may be used to construct a filter expression. In this case, a <code>find</code> query is first executed to identify the item to retrieve. Superfluous property fields will be ignored.</p> <p>The <code>get</code> method returns Javascript properties for the item after applying any schema mappings. Hidden attributes will not be returned.</p> <p>The optional params are fully described in Model API Params. Some relevant params include:</p> <p>The <code>params.fields</code> may be set to a list of properties to return. This defines the ProjectionExpression.</p> <p>If <code>params.execute</code> is set to false, the command will not be executed and the prepared DynamoDB API parameters will be returned.</p> <p>If <code>params.parse</code> is set to true, the results will be parsed and mapped into a set of Javascript properties. By default, the unmodified DynamoDB results are returned.</p> <p>The <code>params.where</code> clause may be used to define a filter expression. This will define a FilterExpression and the ExpressionAttributeNames and ExpressionAttributeValues. See Where Clause for more details.</p>"},{"location":"api/table/methods/#getmodel","title":"getModel","text":"<pre><code>getModel(name)\n</code></pre> <p>Return a model for the given model name.</p>"},{"location":"api/table/methods/#groupbytype","title":"groupByType","text":"<pre><code>groupByType(items)\n</code></pre> <p>Return the items grouped by the configured table typeField property. Returns a map indexed by type name.</p>"},{"location":"api/table/methods/#listmodels","title":"listModels","text":"<pre><code>listModels()\n</code></pre> <p>Return a list of models defined on the <code>Table</code>.</p>"},{"location":"api/table/methods/#listtables","title":"listTables","text":"<pre><code>async listTables()\n</code></pre> <p>Return a list of tables in the database.</p>"},{"location":"api/table/methods/#putitem","title":"putItem","text":"<pre><code>async putItem(properties, params = {})\n</code></pre> <p>Create an item in the database. This API wraps the DynamoDB <code>putItem</code> method.</p> <p>The <code>properties</code> parameter is a Javascript hash containing all the required attributes for the item and must contain the required keys or fields that are used to create the primary key.</p> <p>OneTable will only write fields in <code>properties</code> that correspond to the schema attributes for the model. Superfluous property fields will be ignored.</p> <p>The property names are those described by the schema. NOTE: these are not the same as the attribute names stored in the Database. If a schema uses <code>map</code> to define a mapped attribute name, the Javascript field name and the DynamoDB attribute name may be different.</p> <p>The method returns the unmodified DynamoDB <code>put</code> response. If <code>params.parse</code> is set to true, it will return the Javascript properties created for the item with hidden attributes will not be returned.</p> <p>Before creating the item, all the properties will be validated according to any defined schema validations and all required properties will be checked. Similarly, properties that use a schema enum definition will be checked that their value is a valid enum value. Encrypted fields will be encrypted transparently before writing.</p> <p>The <code>params.fields</code> may be set to a list of properties to return. This defines the ProjectionExpression.</p> <p>If <code>params.execute</code> is set to false, the command will not be executed and the prepared DynamoDB API parameters will be returned.</p> <p>If <code>params.parse</code> is set to true, the results will be parsed and mapped into a set of Javascript properties. Otherwise, the unmodified DynamoDB response will be returned.</p>"},{"location":"api/table/methods/#queryitems","title":"queryItems","text":"<pre><code>async queryItems(properties, params)\n</code></pre> <p>This API invokes the DynamoDB <code>query</code> API and return the results.</p> <p>The properties should include the relevant key properties.</p> <p>The sort key may be defined as a key condition by setting the property to an object that defines the condition. The condition operator is specified as the key, and the operand as the value.</p> <p>These operators may only be used with the sort key property. If the sort key uses a value template, you cannot use the operator on the sort key value directly and not on the properties that are referenced in the value template.</p> <p>For example:</p> <pre><code>let user = await table.queryItems({pk, sk: {begins: 'user:john'}})\nlet tickets = await table.queryItems({pk, sk: {between: [1000, 2000]}})\nlet invoices = await table.queryItems({pk, sk: {'&lt;=': 1000}})\n</code></pre> <p>The operators include:</p> <pre><code>&lt; &lt;= = &lt;&gt; &gt;= &gt;\nbegins or begins_with\nbetween\n</code></pre> <p>Filter Expressions</p> <p>Non-key fields are used to construct a filter expression which is applied by DynamoDB after reading the data but before returning it to the caller. OneTable will utilize fields in <code>properties</code> that correspond to the schema attributes for the model. Superfluous property fields will be ignored in the filter expression.</p> <p>More complex filter expressions may be created via a <code>params.where</code> property. For example:</p> <pre><code>let invoices = await table.queryItems({pk}, {where: '${sk} &lt;= {1000}'})\n</code></pre> <p>See Where Clause for more details.</p> <p>If <code>queryItems</code> is called without a sort key, <code>queryItems</code> will utilize the model type as a sort key prefix and return all matching model items. This can be used to fetch all items that match the primary hash key and are of the specified model type.</p> <p>The <code>queryItems</code> method returns an array of items after applying any schema mappings. Hidden attributes in items will not be returned.</p> <p>Some useful params for queryItems include:</p> <p>The <code>params.index</code> may be set to the desired index name.</p> <p>The <code>params.where</code> clause may be used to define a filter expression. This will define a FilterExpression and the ExpressionAttributeNames and ExpressionAttributeValues. See Where Clause for more details.</p> <p>The <code>params.fields</code> may be set to a list of properties to return. This defines the ProjectionExpression.</p> <p>If <code>params.execute</code> is set to false, the command will not be executed and the prepared DynamoDB API parameters will be returned.</p> <p>If <code>params.parse</code> is set to true, the results will be parsed and mapped into a set of Javascript properties. Otherwise, the unmodified DynamoDB response will be returned.</p>"},{"location":"api/table/methods/#readschema","title":"readSchema","text":"<pre><code>async readSchema(): OneSchema\n</code></pre> <p>Read the <code>Current</code> schema from the table if it has been stored there via <code>saveSchema</code>.</p>"},{"location":"api/table/methods/#readschemas","title":"readSchemas","text":"<pre><code>async readSchemas(): OneSchema[]\n</code></pre> <p>Read all stored schemas from the table.</p>"},{"location":"api/table/methods/#remove","title":"remove","text":"<pre><code>async remove(modelName, properties, params = {})\n</code></pre> <p>Delete an item in the database of the given model <code>modelName</code> as defined in the table schema. Wraps the <code>Model.remove</code> API. See Model.remove for details.</p>"},{"location":"api/table/methods/#removemodel","title":"removeModel","text":"<pre><code>removeModel(name)\n</code></pre> <p>Remove a model from the current schema in use by the table. This does not impact the persisted schemas.</p>"},{"location":"api/table/methods/#removeschema","title":"removeSchema","text":"<pre><code>removeSchema(schema)\n</code></pre> <p>Remove a schema from the persisted <code>Table</code> schema items. The schema should include a <code>name</code> property that describes the schema.</p>"},{"location":"api/table/methods/#saveschema","title":"saveSchema","text":"<pre><code>async saveSchema(schema?: OneSchema): OneSchema\n</code></pre> <p>Save the current schema to the table using the _Schema:_Schema hash/sort key pair.</p> <p>If the schema parameter is null or not provided, the currently configured schema will be saved. If a schema is provided and the schema.params is unset, the saved schema will include the current Table parms.</p>"},{"location":"api/table/methods/#scanitems","title":"scanItems","text":"<pre><code>async scanItems(params)\n</code></pre> <p>Invokes the DynamoDB <code>scan</code> API and return the results.</p> <p>Some relevant params include:</p> <p>The <code>params.where</code> clause may be used to define a filter expression. This will define a FilterExpression and the ExpressionAttributeNames and ExpressionAttributeValues. See Where Clause for more details.</p> <p>The <code>params.fields</code> may be set to a list of properties to return. This defines the ProjectionExpression.</p> <p>If <code>params.execute</code> is set to false, the command will not be executed and the prepared DynamoDB API parameters will be returned.</p> <p>If <code>params.parse</code> is set to true, the results will be parsed and mapped into a set of Javascript properties. Otherwise, the unmodified DynamoDB response will be returned.</p> <p>The scan method supports parallel scan where you invoke scan simultaneously from multiple workers. Using the async/await pattern, you can start the workers and then use a Promise.all to wait for their completion. To perform parallel scans, you should set the <code>params.segments</code> to the number of parallel segements and the <code>params.segment</code> to the numeric segment to be scaned for that worker.</p> <pre><code>const segments = 4\nlet promises = []\nfor (let segment = 0; segment &lt; segments; segment++) {\n    promises.push(table.scanItems({}, {segment, segments}))\n}\nlet results = await Promise.all(promises)\n</code></pre>"},{"location":"api/table/methods/#setclient","title":"setClient","text":"<pre><code>setClient(client)\n</code></pre> <p>Assign an AWS SDK V2 DocumentClient or AWS SDK V3 Dynamo helper client to be used for communiction with DynamoDB. Note the V3 DocumentClient instance is a native AWS SDK DocumentClient instance. For AWS SDK V3, the client is an instance of the OneTable Dynamo helper.</p>"},{"location":"api/table/methods/#setcontext","title":"setContext","text":"<pre><code>setContext(context = {}, merge = false)\n</code></pre> <p>Set the table <code>context</code> properties. If <code>merge</code> is true, the properties are blended with the existing context.</p>"},{"location":"api/table/methods/#setschema","title":"setSchema","text":"<pre><code>async setSchema(schema?: OneSchema)\n</code></pre> <p>Set the current schema for the table instance. This will reset the current schema. If the schema parameter contains a schema.params, these will be applied and overwrite the current Table params.</p> <p>If the schema property is null, the current schema will be removed.</p>"},{"location":"api/table/methods/#transact","title":"transact","text":"<pre><code>async transact(operation, transaction, params = {})\n</code></pre> <p>Invoke a prepared transaction and return the results. Transactions are prepared by creating a bare transaction object <code>{}</code> and passing that via <code>params.transaction</code> to the various OneTable APIs to build up a transactional operation. Finally invoking <code>transact</code> will execute the accumulated API calls within a DynamoDB transaction.</p> <p>The <code>operation</code> parameter should be set to <code>write</code> or <code>get</code>.</p> <p>The <code>transaction</code> parameter should initially be set to <code>{}</code> and then be passed to API calls via <code>params.transaction</code>.</p> <p>A <code>get</code> operation will return an array containing the items retrieved.</p> <p>The <code>Table.groupBy</code> can be used to organize the returned items by model. E.g.</p> <pre><code>let transaction = {}\nawait table.get('Account', {id: accountId}, {transaction})\nawait table.get('User', {id: userId}, {transaction})\nlet items = await table.transact('get', transaction, {parse: true, hidden: true})\nitems = table.groupByType(items)\nlet accounts = items.Account\nlet users = items.User\n</code></pre>"},{"location":"api/table/methods/#update","title":"update","text":"<pre><code>async update(modelName, properties, params = {})\n</code></pre> <p>Update an item in the database of the given model <code>modelName</code> as defined in the table schema. Wraps the <code>Model.update</code> API. See Model.update for details.</p>"},{"location":"api/table/methods/#updateitem","title":"updateItem","text":"<pre><code>async updateItem(properties, params)\n</code></pre> <p>Update an item in the database. This method wraps the DynamoDB <code>updateItem</code> API.</p> <p>The <code>properties</code> parameter is a Javascript hash containing properties to update including the required keys or fields that are used to create the primary key.</p> <p>OneTable will only update fields in <code>properties</code> that correspond to the schema attributes for the model. Superfluous property fields will be ignored.</p> <p>The property names are those described by the schema. NOTE: these are not the same as the attribute names stored in the Database. If a schema uses <code>map</code> to define a mapped attribute name, the Javascript field name and the DynamoDB attribute name may be different.</p> <p>The method returns the unmodified DynamoDB response. If <code>params.parse</code> is true, the call returns the Javascript properties for the item with hidden attributes removed.</p> <p>The optional params are described in Model API Params.   </p> <p>The <code>params.fields</code> may be set to a list of properties to return. This defines the ProjectionExpression.</p> <p>If <code>params.execute</code> is set to false, the command will not be executed and the prepared DynamoDB API parameters will be returned. However, if set on an update that has a unique field, the commands will not be returned. This is because and update with a unique field requires a transaction and multiple commands. In this case, setting execute: true will cause the command to not be executed as expected, but the the proposed commands will not be returned. To see the commands, set the parmas.log to true to log the commands to the console.</p> <p>If <code>params.parse</code> is set to true, the results will be parsed and mapped into a set of Javascript properties. Otherwise, the unmodified DynamoDB response will be returned.</p>"},{"location":"api/table/methods/#updatetable","title":"updateTable","text":"<pre><code>async updateTable(params)\n</code></pre> <p>Update a table and create or remove a Global Secondary Index.  </p> <p>Set <code>params.create</code> to an index to create. Set <code>create</code> to a map with properties for the <code>hash</code> and <code>sort</code> attributes. E.g.</p> <p><pre><code>await table.updateTable({create: {\nhash: 'gs1pk',\nhash: 'gs2pk',\nname: 'gs1',\n}})\n</code></pre> Set <code>params.remove</code> to remove an index. Set <code>remove</code> to a map with a <code>name</code> property of the table to remove. E.g.</p> <pre><code>await table.updateTable({remove: {\nname: 'gs1'\n}})\n</code></pre>"},{"location":"api/table/methods/#uuid","title":"UUID","text":"<pre><code>uuid()\n</code></pre> <p>Internal routine to generate a simple, fast non-cryptographic UUID string. This routine is provided for use in the browser where Node crypto is not availble. The uuid function will generate IDs that have the same format as a UUID v4 string. However they are not crypto-grade in terms of uniqueness nor are they fully compliant in the composition of the UUID sub-components. In general, use <code>ulid</code> in preference to <code>uuid</code>.</p> <p>This routine</p>"},{"location":"api/table/methods/#ulid","title":"ULID","text":"<pre><code>ulid()\n</code></pre> <p>Generate a ULID. Useful when you need a time-based sortable, cryptographic, unique sequential number. This is preferable to using <code>uuid</code>.</p>"},{"location":"api/table/overview/","title":"Overview","text":"<p>The <code>Table</code> class is the top-most OneTable class and it represents a single DynamoDB table. The table class configures access to a DynamoDB table, defines the model (entity) schema, indexes, crypto and defaults. You can create a single <code>Table</code> instance or if you are working with multiple tables, you can create one instance per table.</p> <p>The Table class defines the connection to your DynamoDB table and specifies your data schema including application entity models and index structure.</p> <p>The Table class provides APIs for table operations, transactions and batch API operations. While most access to the database is via the <code>Model</code> methods, the Table class also provides a convenience API to wrap the <code>Model</code> methods so you can specify the required model by a string name. The is helpful for factory design patterns.</p>"},{"location":"api/table/constructor/constructor/","title":"Constructor","text":"<p>The Table class is used to create an instance for each DynamoDB table you wish to access.</p> <p>For each table, you define the table name, an AWS DynamoDB client connection object and a schema that defines your data model.</p> <pre><code>import {Table} from 'dynamodb-onetable'\nconst table = new Table({\nclient: DocumentClientInstance,\nname: 'MyTable',\nschema: Schema,\n})\n</code></pre> <p>The Table constructor takes a parameter of type <code>object</code> with the following properties:</p> Property Type Description client <code>DocumentClient</code> An AWS DocumentClient instance. crypto <code>object</code> Optional properties defining a crypto configuration to encrypt properties. generate <code>function</code> Define a custom ID generator function that is used to create model IDs if required. hidden <code>boolean</code> Return hidden fields by default. Default is false. logger <code>boolean|object</code> Set to true to log to the console or set to a logging function(type, message, properties). Type is info metrics <code>object</code> Configure metrics. Default null. name <code>string</code> The name of your DynamoDB table. partial <code>boolean</code> Allow partial object updates. This may be overridden on a schema per-field, or per-API basis. Default is true. schema <code>string</code> Definition of your DynamoDB indexes and models. senselogs <code>object</code> Set to a SenseLogs logger instance instead <code>logger</code>. Default null. transform <code>function</code> Callback function to be invoked to format and parse the data before reading and writing. validate <code>function</code> Function to validate properties before issuing an API. value <code>function</code> Function to evaluate value templates. Default null. warn <code>boolean</code> Emit warnings. Default true. <p>The <code>client</code> property must be an initialized DynamoDBClient instance. For the old AWS V2 SDK, you supply a AWS DocumentClient instance.</p> <p>By default, OneTable will not write <code>null</code> values to the database rather, it will remove the corresponding attribute from the item. If you set the <code>nulls</code> property to true, <code>null</code> values will be written via <code>create</code> or <code>update</code>. You can also define <code>nulls</code> on a model attribute basis via the schema.</p> <p>The <code>metrics</code> property may be set to a map that configures detailed CloudWatch EMF metrics. See Metrics for more information.</p> <p>The <code>schema</code> property must be set to your OneTable schema that defines your data model. See Schemas for details.</p>"},{"location":"api/table/constructor/constructor/#partial-properties","title":"Partial Properties","text":"<p>If the <code>partial</code> constructor property is true, you can specify partial objects when updating and only the supplied properties will be updated. If <code>partial</code> is false, then any objects supplied in the properties will replace the existing item object. i.e. partial permits updating individual object properties without having to provide the entire object. The default value for partial is now true.</p> <p>For example, with partial set to true, you can do an update and only update an individual nested property:</p> <pre><code>let user = await User.create({\nname: 'Road Runner',\naddress: {\nstreet: '444 Coyote Lane',\n}\n})\n//  Update just the zip code\nawait User.update({\nid: user.id\naddress: {\nzip: 98103\n}\n})\n</code></pre> <p>Without <code>partial</code> set to true, the preceding update would have overwritten the address with just the zip code.</p> <p>When using <code>partial</code> set to true, you must ensure the enclosing object exists before doing the update. You can ensure this by setting the schema field <code>default</code> to <code>{}</code>. For the example above, the address would have been defined as:</p> <pre><code>const schema = {\nmodels: {\nUser: {\npk: {type: 'string', value: '${_type}#'},\nsk: {type: 'string', value: '${_type}#${id}'},\nname: {type: 'string'},\nid: {type: 'string', generate: 'uid'},\naddress: {\ntype: 'object',\ndefault: {},\nschema: {\naddress: {type: 'string'},\nzip: {type: 'number'},\n}\n}\n}\n}\n}\n</code></pre> <p>Partial can also be defined in a schema field definition and in the API params. </p> <p>Partial updates of arrays are not (yet) supported. You should specify <code>partial: false</code> in any schema array property if you are using partial updates in general.</p> <p>The API params value of partial will override, the per-field definition which will override the table <code>partial</code> value.</p>"},{"location":"api/table/constructor/constructor/#aws-dynamodb-accelerator-dax","title":"AWS DynamoDB Accelerator (DAX)","text":"<p>The Amazon DynamoDB Accelerator is a fully managed, highly available, in-memory cache for DynamoDB. OneTable supports DAX.</p> <p>Currently, the AWS SDK V3 does not support DAX via by the DynamoDBClient package so you must use the AWS SDK V2.</p> <p>Here is as sample initialization code for DAX:</p> <pre><code>import {DynamoDB} from 'aws-sdk'\nimport AmazonDaxClient from 'amazon-dax-client'\nconst endpoint = \"dax://DAX-CLUSTER-ENDPOINT\"\nconst dax = new AmazonDaxClient({endpoints: [endpoint], region: 'AWS_REGION'})\nconst client = new DynamoDB.DocumentClient({service: dax})\n</code></pre>"},{"location":"api/table/constructor/crypto/","title":"Crypto","text":"<p>OneTable can apply additional encryption for sensitive data fields such as email addresses, credit card information or other PII. This is useful as an additional layer of security for passwords, keys and other especially sensitive information.</p> <p>While Amazon does encrypt the data at rest internally, this additional encryption safeguards backups and should Amazon ever make a mistake with your data.</p> <p>The Table constructor <code>crypto</code> property defines the configuration used to encrypt and decrypt attributes that specify <code>crypt: true</code> in their schema.</p> <p>The crypto property should be set to a hash that a \"primary\" property that contains the <code>cipher</code> to use and an encryption secret/password. Currently, only a single encryption key called \"primary\" is supported. </p> <p>For example:</p> <pre><code>let db = new Table({\nclient: DocumentClientInstance,\nname: 'MyTable',\nschema: Schema,\ncrypto: {\nprimary: {\ncipher: 'aes-256-gcm',\npassword: '16719023-772f-133d-1111-aaaa7722188f'\n}\n},\n}\n</code></pre>"},{"location":"api/table/constructor/logging/","title":"Logging","text":"<p>OneTable can log complete request parameters and responses to assist you in debugging and understanding how your API requests are being translated to DynamoDB.</p> <p>You can set the Table constructor <code>logger</code> property to <code>true</code> for simple logging to the console.</p> <pre><code>const table = new Table({\n...\nlogger: true,\n})\n</code></pre> <p>Alternatively, the <code>logger</code> may be set to logging callback that will be invoked as required to log data. The logger function has the signature:</p> <pre><code>const table = new Table({\n...\nlogger: (level, message, context) =&gt; {\nif (level == 'trace' || level == 'data') return\nconsole.log(`${new Date().toLocaleString()}: ${level}: ${message}`)\nconsole.log(JSON.stringify(context, null, 4) + '\\n')\n}\n})\n</code></pre> <p>Where <code>level</code> is set to <code>info</code>, <code>error</code>, <code>warn</code>, <code>exception</code>, <code>trace</code> or <code>data</code>. The <code>trace</code> level is for verbose debugging messages. The <code>data</code> level logs user data retrieved find and get API calls.</p> <p>The <code>message</code> is a simple String containing a descriptive message. The <code>context</code> is a hash of contextual properties regarding the request, response or error.</p> <p>If you use {log: true} in the various OneTable Model API options, the more verbose <code>trace</code> and <code>data</code> levels will be changed to <code>info</code> for that call before passing to the logging callback. In this way you can emit <code>trace</code> and <code>data</code> output on a per API basis.</p>"},{"location":"api/table/constructor/logging/#senselogs","title":"SenseLogs","text":"<p>OneTable also integrates with SenseLogs which is a fast dynamic logger designed for serverless.</p> <pre><code>import SenseLogs from 'senselogs'\nconst senselogs = new SenseLogs()\nconst table = new Table({senselogs})\n</code></pre> <p>This will log request details in JSON. Use <code>SenseLogs({destination: 'console'})</code> for plain text logging to the console.</p>"},{"location":"api/table/constructor/metrics/","title":"Metrics","text":"<p>OneTable can emit detailed custom metrics to track DynamoDB performance and usage on a per app/function, index, entity model and operation basis.  </p> <p>These metrics can be emitted using Cloud Watch metrics or CustomMetrics</p> <p>SenseDeep can present and analyze these metrics to gain insights and visualizations into how your single-table designs are performing.</p>"},{"location":"api/table/constructor/metrics/#metric-details","title":"Metric Details","text":"<p>The following metrics are emitted:</p> Metric Description read Read capacity units consumed write Write capacity units consumed latency Aggregated request latency in milliseconds count Count of items returned scanned Number of items scanned requests Number of API requests issued <p>Each of these metric can be emitted for the following dimensions:</p> Dimension Description Table Tentant Customer or user responsible for the database access Index Primary or secondary index Source Application, service or function responsible for the access Model Single table model Operation DynamoDB operation <p>The default dimension are Table, Index, Source and Model. </p> <p>The dimensions are emitted for progressive combinations. i.e. Table, Table+Tenant, Table+Tenant+Index, etc. This means you can see detailed metrics at multiple levels. You can see overall metrics for the table, or a table and index, or for the table, index and application. </p>"},{"location":"api/table/constructor/metrics/#metrics-params","title":"Metrics Params","text":"<p>The properties of Table constructor <code>params.metrics</code> property are:</p> Property Type Description chan <code>string</code> Log channel to use to emit metrics if using SenseLogs. Defaults to 'dbmetrics'. dimensions <code>array</code> Ordered array of dimensions to emit. Defaults to [Table, Index, Source] and includes Tenant if the <code>tenant</code> property is set to true. This can be modified at runtime via the LOG_ONETABLE_DIMENSIONS Lambda environment variable. enable <code>boolean</code> Set to true to enable metrics. Defaults to true. env <code>boolean</code> Set to true to enable dynamic control via the LOG_FILTER environment variable. Defaults to true. max <code>number</code> Number of DynamoDB API calls for which to buffer metrics before flushing. Defaults to 100. namespace <code>string</code> CloudWatch metrics namespace for the metrics. Defaults to <code>SingleTable/metrics.1</code>. period <code>number</code> Number of seconds to buffer metrics before flushing. Defaults to 30 seconds. properties <code>map|function</code> Set to a map of additional properties to be included in a CloudWatch EMF log record. These are not metrics. Set to a function that will be invoked as <code>properties(operation, params, result)</code> and should return a map of properties. Defaults to null. source <code>string</code> Name of application or function name that is calling DynamoDB. Default to the Lambda function name. tenant <code>string</code> Set to an identifying string for the customer or tenant. Defaults to null."},{"location":"api/table/constructor/metrics/#dynamic-control","title":"Dynamic Control","text":"<p>Metrics can be dynamically controlled by the LOG_FILTER environment variable. If this environment variable contains the string <code>dbmetrics</code> and the <code>env</code> params is set to true, then Metrics will be enabled. If the <code>env</code> parameter is unset, LOG_FILTER will be ignored.</p> <pre><code>const table = new Table({\nmetrics: {source: 'acme:launcher', env: true}\n})\n</code></pre> <p>You can also use the LOG_OVERRIDE environment variable. This operates like LOG_FILTER but for a specified duration of time. The format of LOG_OVERRIDE is:</p> <pre><code>expire: filter\n</code></pre> <p>Where <code>expire</code> is a Unix time in msec since Jan 1, 1970 (Date.now()) and filter is a LOG_FILTER string containing <code>dbmetrics</code>.</p> <p>The metric dimensions can be controlled by the LOG_ONETABLE_DIMENSIONS environment variable. Set to an ordered, comma separated list of dimensions. The dimensions will be progressively combined. i.e. A dimensions list of [Table, Index, Source] will result in the dimensions [{Table}, {Table+Index}, {Table+Index+Source}]. </p>"},{"location":"api/table/constructor/metrics/#profiled-queries","title":"Profiled Queries","text":"<p>You can also generate metrics for specially profiled queries and scans via the <code>params.profile</code> tag. The profile param takes a unique string tag and metrics will be created for the dimension {Profile: profile-tag-name}. These metrics exist outside the standard dimensions specified via the Metrics <code>dimensions</code> parameter.</p> <pre><code>await User.find({}, {profile: 'find-all-users'})\n</code></pre>"},{"location":"api/table/constructor/metrics/#performance-and-cost","title":"Performance and Cost","text":"<p>Single table metrics are very granular and the combination of metric dimensions can get large. This can impose a significant load on your applications and database (if using CustomMetrics) or CloudWatch Metrics if using EMF. </p> <p>To minimize the cost, only use the metric dimensions you really require. Also, use the dynamic log control environment variables LOG_FILTER and LOG_ONETABLE_DIMENSIONS to enable and disable OneTable metrics for short durations. SenseDeep makes this easy, by supporting override log environment variables that automatically</p> <p>The other way to minimize the performance impact is to use a larger <code>period</code> and <code>max</code> property in your Table <code>params.metrics</code> constructor property.</p>"},{"location":"api/table/constructor/metrics/#background","title":"Background","text":"<p>OneTable Metrics are emitted using either CloudWatch EMF or CustomMetrics. </p> <p>AWS CloudWatch offers metrics to monitor specific aspects of your apps that are not covered by the default AWS infrastructure metrics. </p> <p>Unfortunately, the AWS \"custom\" metrics can be very expensive. If updated or queried regularly. Each each custom metric will cost up to $5 per metric per year with additional costs for querying. If you have many metrics or high dimensionality on your metrics, this can lead to a very large CloudWatch Metrics bill.</p>"},{"location":"api/table/constructor/metrics/#custom-metrics","title":"Custom Metrics","text":"<p>CustomMetrics provides cost effective metrics that are up to 1000 times cheaper and 10 times faster than standard CloudWatch metrics.</p> <p>CustomMetrics achieves these savings by supporting only \"latest\" period metrics. i.e. last day, last month, last hour etc. This enables each metric to be saved, stored and queried with minimal cost.</p> <p>CustomMetrics stores metric data in your DynamoDB database table using a unique key so that it can co-exist with your application data. Metric data is buffered and aggregated so the impact on your DynamoDB utilization should be minimal.</p> <p>CustomMetrics are emitted using a primary key of <code>metric#1#owner</code>. MOB -- config option</p>"},{"location":"api/table/constructor/metrics/#cloudwatch-emf","title":"CloudWatch EMF","text":"<p>Metric emitted using CloudWatch EMF permit zero-latency creation of metrics without impacting the performance of your Lambdas.</p> <p>If your CloudWatch costs are too high, you can minimize your charges by reducing the number of dimensions via the <code>dimensions</code> property. You could consider disabling the <code>source</code> or <code>operation</code> dimensions. Alternatively, you should consider SenseLogs which integrates with OneTable and can dynamically control your metrics to enable and disable metrics dynamically.</p> <p>DynamoDB Metrics are buffered and aggregated to minimize the load on your system. If a Lambda function is reclaimed by AWS Lambda, there may be a few metric requests that are not emitted before the function is reclaimed. This should be a very small percentage and should not significantly impact the quality of the metrics. You can control this buffering via the <code>max</code> and <code>period</code> parameters.</p>"},{"location":"api/table/constructor/metrics/#read-more","title":"Read More","text":"<p>Read more about how to use and configure metrics at Understanding Your DynamoDB Performance.</p> <p>The metrics can be viewed in CloudWatch or best via SenseDeep which has detailed graphs for your single-table monitoring for DynamoDB.</p> <p>.</p>"},{"location":"api/table/constructor/templates/","title":"Value Templates","text":"<p>Value templates are defined in the schema for model fields. These are typically literal strings with property variable references. In some use cases, more complex logic for a value template requires a function to calculate the property value at runtime.</p> <p>The Table constructor <code>params.value</code> function provides a centralized place to evaluate value templates. It will be invoked for fields that define their value template to be <code>true</code>.</p> <p>The value template function is called with the signature:</p> <pre><code>str = value(model, fieldName, properties, params)\n</code></pre> <p>The value template should return a string to be used for the given fieldName. The <code>properties</code> and <code>params</code> are corresponding arguments given to the API.</p>"},{"location":"api/table/constructor/transforms/","title":"Transforms","text":"<p>The optional Table <code>transform</code> function will be invoked on read and write requests to transform data before reading or writing to the table. The transform function can be used for custom storage formats or to assist with data migrations. The transform function can modify the item as it sees fit and return the modified item. The invocation signature is:</p> <pre><code>item = transform(model, operation, item, properties, params, raw)\n</code></pre> <p>Where <code>operation</code> is set to 'read' or 'write'. The <code>params</code> and <code>properties</code> are the original params and properties provided to the API call. When writing, the <code>item</code> will contain the already transformed properties by the internal transformers. You can overwrite the value in <code>item</code> using your own custom transformation logic using property values from <code>properties</code>.</p> <p>When reading, the <code>item</code> will contain the already transformed read data and the <code>raw</code> parameter will contain the raw data as read from the table before conversion into Javascript properties in <code>item</code> via the internal transformers.</p> <p>You can also use a <code>params.transform</code> with many Model APIs. See Model Transformations for details.</p>"},{"location":"api/table/constructor/validations/","title":"Validations","text":"<p>The optional Table <code>validate</code> function will be invoked on requests to enable property validation before writing to the table. The invocation signature is:</p> <pre><code>details = validate(model, properties, params)\n</code></pre> <p>The validation function must return a map of validation messages for properties that fail validation checks. The map is indexed by the property field name.</p>"},{"location":"api/table/schemas/attributes/","title":"Model Attributes","text":"<p>The following attribute properties are supported:</p> Property Type Description crypt <code>boolean</code> Set to true to encrypt the data before writing. default <code>string</code> Default value to use when creating model items or when reading items without a value. enum <code>array</code> List of valid string values for the attribute. encode <code>array</code> Define how an attribute is encoded in a value template. generate <code>string|boolean</code> Set to 'uid', 'ulid' or 'uuid' to automatically create a new ID value for the attribute when creating new items. Set to true to use a custom ID generator defined via the Table params.generate option. Default to null. hidden <code>boolean</code> Set to true to hide the attribute in the returned Javascript results. Attributes with a \"value\" template defined will by hidden by default. Default to the Table params value. isoDates <code>boolean</code> Set to true to store dates as Javascript ISO strings vs epoch numerics. If unset, the field will use the table default value for isoDates. Default to the schema params value. items <code>object</code> Nested schema used to enforce types for items in an array if the attribute type is <code>Array</code>. map <code>string</code> Map the field value to a different attribute name when storing in the database. Can be a simple attribute name or a compound \"obj.name\" where multiple fields can be stored in a single attribute containing an object with all the fields. nulls <code>boolean</code> Set to true to store null values or false to remove attributes set to null. Default false. partial <code>boolean</code> Allow partial object updates for this field. May be used only when the field type is an object with nested schema. This overrides any value for partial given via the Table constructor. This may be overridden by an API params.partial value. Default is null. required <code>boolean</code> Set to true if the attribute is required. Default to the schema params value. reference <code>string</code> Describes a reference to another entity item. Format is: model:index:attribute=src-attribute,... schema <code>object</code> Nested schema. scope <code>string</code> Scope within which a unique attribute will be created. This is a template value to incorporate with the unique attributes. When expanded, this value is added to the unique attribute created for unique fields. Default to null. timestamp <code>boolean</code> Set to true to flag this field as a generated timestamp. Only used with Typescript so the generated type signature for the create() API will not require timestamp properties to be provided. ttl <code>boolean</code> Set to true to convert a supplied date value to a DynamoDB TTL seconds value. The supplied date value can be a Date instance, a number representing a Unix epoch in milliseconds since Jan 1, 1970 or a string that can be parsed by Date.parse. OneTable will divide the Javascript date value by 1000 to get a DynamoDB TTL seconds value. type <code>Type or string</code> Type to use for the attribute. unique <code>boolean</code> Set to true to enforce uniqueness for this attribute. See the \"scope\" property to define a reduced scope for the unique attribute. Default false. validate <code>RegExp</code> Regular expression to use to validate data before writing. value <code>string</code> Template to derive the value of the attribute. These attributes are \"hidden\" by default."},{"location":"api/table/schemas/attributes/#default","title":"Default","text":"<p>If the <code>default</code> property defines the default value for an attribute. If no value is provided for the attribute when creating a new item, the <code>default</code> value will be used.</p>"},{"location":"api/table/schemas/attributes/#encode","title":"Encode","text":"<p>The <code>encode</code> property defines how an attribute is encoded in a value template. It is useful to save redundantly storing attributes separately when they are encoded into other attribute via value templates. If you have an attribute that is used in value template, it is redundant to store that attribute separately. For example:</p> <pre><code>User: {\n    pk:        { type: 'string', value: 'account#${accountId}' },\n    sk:        { type: 'string', value: 'user#${id}' },\n    accountId: { type: 'string', generate: 'uid' },\n    id:        { type: 'string', generate: 'uid' },\n}\n</code></pre> <p>In this example, the accountId and user ID are encoded in the PK and SK and are also stored redundantly in accountId and id. To save space, use encode:</p> <pre><code>User: {\n    pk:        { type: 'string', value: 'account#${accountId}' },\n    sk:        { type: 'string', value: 'user#${id}' },\n    accountId: { type: 'string', generate: 'uid', encode: 'pk' },\n    id:        { type: 'string', generate: 'uid', encode: 'sk' },\n}\n</code></pre> <p>The encode property references the attribute that encodes the nominated field. To use encoding, you must define your separator in the Schema params.separator. </p> <p>If your value template has embeddings that are ambiguous or different separators, you can also define the encode property as an array with three components. The array specifies the attribute name encoding the property, what is the separator delimiting the portions of the value template and the index of the attribute (when split at the delimiters). For example:</p> <pre><code>accountId: { type: 'string', generate: 'uid', encode: ['pk', '#', 1] }\n</code></pre> <p>In this exmample, the accountId is encoded in pk attribute and the accountId is found at the 1st embedded component in the pk. </p> <p>NOTE: When data items are create or queried, you can provide and access the encoded property via named references. i.e. The encoding is transparent.</p>"},{"location":"api/table/schemas/attributes/#generate","title":"Generate","text":"<p>The <code>generate</code> property will generate an attribute value when creating new items. If set to 'uuid', then a non-crypto grade UUIDv4 format ID will be generated. If set to ULID, a crypto-grade, time-sortable random ID will be created. If set to 'uid' a shorter 10 character ID will be created.</p> <p>You can also use and generate: 'uid(NN)' to generate shorter, less unique identifiers. A UID by default is ten letters long and supports a similar charset as the ULID (Uppercase and digits, base 32 excluding I, L, O and U.). So a 10 character UID is 32^10 which is over 1 quintillion possibilities. You can supply the length to the generate value to get an arbitrary length. For example: </p> <pre><code>generate: 'uid(16)'\n</code></pre>"},{"location":"api/table/schemas/attributes/#hidden","title":"Hidden","text":"<p>If the <code>hidden</code> property is set to true, the attribute will be defined in the DynamoDB database table, but will be omitted in the returned Javascript results.</p>"},{"location":"api/table/schemas/attributes/#isodates","title":"IsoDates","text":"<p>If the <code>isoDates</code> property is defined and not-null, it will override the table isoDates value. Set to true to store the field date value as an ISO date string. Set to false to store the date as a Unix epoch date number.</p>"},{"location":"api/table/schemas/attributes/#map","title":"Map","text":"<p>The <code>map</code> property can be used to set an alternate or shorter attribute name when storing in the database. The map value may be a simple string that will be used as the actual attribute name.</p> <p>Alternatively, the map value can be a pair of the form: 'obj.name', where the attribute value will be stored in an object attribute named \"obj\" with the given name <code>name</code>. Such two-level mappings may be used to map multiple properties to a single table attribute. This is helpful for the design pattern where GSIs project keys plus a single 'data' field and have multiple models map relevant attributes into the projected 'data' attribute. OneTable will automatically pack and unpack attribute values into the mapped attribute. Note: APIs that write to a mapped attribute must provide all the properties that map to that attribute on the API call. Otherwise an incomplete attribute would be written to the table.</p>"},{"location":"api/table/schemas/attributes/#reference","title":"Reference","text":"<p>The <code>reference</code> attribute documents a reference to another entity by using this attribute in combination with other attributes. The format is:</p> <pre><code>model:index:attribute=source-attribute,...\n</code></pre> <p>The \"model\" selects that target entity model of the reference using the nominated \"index\" where the target \"attribute\" is determined by the associated source-attribute. Multiple attributes can be specified. Tools can use this reference to navigate from one entity item to another.</p>"},{"location":"api/table/schemas/attributes/#schema","title":"Schema","text":"<p>The <code>schema</code> property permits nested field definitions. The parent property must be an Object as the type of items in arrays are defined using the <code>items</code> property.</p>"},{"location":"api/table/schemas/attributes/#ttl","title":"TTL","text":"<p>The <code>ttl</code> property supports DynamoDB TTL expiry attributes. Set to true to store a supplied date value as a Unix epoch in seconds suitable for use as a DynamoDB TTL attribute.</p>"},{"location":"api/table/schemas/attributes/#type","title":"Type","text":"<p>The <code>type</code> properties defines the attribute data type. Valid types include: String, Number, Boolean, Date, Object, Null, Array, Buffer (or Binary) and Set. The object type is mapped to a <code>map</code>, the array type is mapped to a <code>list</code>. Dates are stored as Unix numeric epoch date stamps unless the <code>isoDates</code> parameter is true, in which case the dates are store as ISO date strings. Binary data is supplied via <code>buffer</code> types and is stored as base64 strings in DynamoDB.</p>"},{"location":"api/table/schemas/attributes/#validate","title":"Validate","text":"<p>The <code>validate</code> property defines a regular expression that is used to validate data before writing to the database. Highly recommended.</p>"},{"location":"api/table/schemas/attributes/#value-templates","title":"Value Templates","text":"<p>The <code>value</code> property defines a literal string template that is used to compute the attribute value. This is useful for computing key values from other properties, creating compound (composite) sort keys or for packing fields into a single DynamoDB attribute when using GSIs.</p> <p>String templates are similar to JavaScript string templates. The template string may contain <code>${name}</code> references to other fields defined in the entity model. If any of the variable references are undefined when an API is called, the computed field value will be undefined and the attribute will be omitted from the operation. The variable <code>name</code> may be of the form: <code>${name:size:pad}</code> where the name will be padded to the specified size using the given <code>pad</code> character (which default to '0'). This is useful for zero padding numbers so that they sort numerically.</p> <p>If you call <code>find</code> or any query API and do not provide all the properties needed to resolve the complete value template. i.e. some of the ${var} references are unresolved, OneTable will take the resolved leading portion and create a <code>begins with</code> key condition for that portion of the value template.</p>"},{"location":"api/table/schemas/indexes/","title":"Indexes","text":"<p>The <code>schema.indexes</code> property can contain one or more indexes and must contain the <code>primary</code> key. Additional indexes will be treated as Global Secondary Indexes (GSIs) unless they are defined with a <code>type: \"local\"</code> property in which case they will be designated as Local Secondary Indexes (LSIs). An LSI index should not specify a hash attribute. If one is specified, it must equal that of the primary index.</p> <pre><code>const MySchema = {\nindexes: {\nprimary: {\nhash: 'pk',         //  Schema property name of the hash key\nsort: 'sk',         //  Schema property name of the sort key\n},\n//  Zero or more global secondary or local secondary indexes\ngs1: {\nhash: 'gs1pk',\nsort: 'gs1sk',\nproject: 'all',\nfollow: true,\n},\nls1: {\ntype: 'local'\nsort: 'id',\n}\n...\n}\n</code></pre> <p>Note: the hash and sort names are schema property names which may differ from table attribute names if you are using mapping.</p> <p>The <code>project</code> property can be set to 'all' to project all attributes to the secondary index, set to 'keys' to project only keys and may be set to an array of attributes (not properties) to specify an explicit list of attributes to project. The <code>project</code> property is used by the Table.createTable and updateTable APIs only.</p> <p>The <code>follow</code> property is used to support GSI indexes that project KEYS_ONLY or only a subset of an items properties. When <code>follow</code> is true, any fetch of an item via the GSI will be transparently followed by a fetch of the full item using the primary index and the GSI projected keys. This incurs an additional request for each item, but for large data sets, it is useful to minimize the size of a GSI and yet retain access to full items.</p>"},{"location":"api/table/schemas/modeling/","title":"Data Modeling","text":"<p>OneTable models your application entities via a OneTable schema. The schema defines your table structure, indexes, application entities and their attributes. It specifies how items will be stored to and retrieved from your DynamoDB table.</p> <p>Here is a sample schema:</p> <pre><code>const MySchema = {\nformat: 'onetable:1.1.0',\nversion: '0.0.1',\nindexes: {\nprimary: { hash: 'pk', sort: 'sk' },\ngs1:     { hash: 'gs1pk', sort: 'gs1sk', follow: true },\nls1:     { sort: 'id', type: 'local' },\n},\nmodels: {\nAccount: {\npk:          { type: String, value: 'account#${name}' },\nsk:          { type: String, value: 'account#' },\nid:          { type: String, generate: 'ulid',\nvalidate: /^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$/i },\nname:        { type: String, required: true, encode: 'pk' },\nstatus:      { type: String, default: 'active' },\nzip:         { type: String },\n},\nUser: {\npk:          { type: String, value: 'account#${accountName}' },\nsk:          { type: String, value: 'user#${email}',\nvalidate: EmailRegExp },\nid:          { type: String, required: true },\naccountName: { type: String, required: true, encode: 'pk' },\nemail:       { type: String, required: true, encode: 'sk' },\nfirstName:   { type: String, required: true },\nlastName:    { type: String, required: true },\nusername:    { type: String, required: true },\nrole:        { type: String, enum: ['user', 'admin'], required: true,\ndefault: 'user' },\nbalance:     { type: Number, default: 0 },\ngs1pk:       { type: String, value: 'user-email#${email}' },\ngs1sk:       { type: String, value: 'user#' },\n}\n},\nparams: {\n'isoDates': true,\n'separator': '#',\n'timestamps': true,\n},\n}\n</code></pre> <p>For each entity model, you define the entity attributes, their type and other attribute properties such as whether the attribute must be unique or have its value computed from other attributes.</p> <p>When you invoke the Table constructor, the <code>schema</code> property must be set to your schema.</p> <pre><code>import {Table} from 'dynamodb-onetable'\nconst table = new Table({\nclient: DocumentClientInstance,\nname: 'MyTable',\nschema: Schema,\n})\n</code></pre>"},{"location":"api/table/schemas/modeling/#schema-properties","title":"Schema Properties","text":"<p>The valid properties of the <code>schema</code> object are:</p> Property Type Description format <code>string</code> Reserved. Must be set to 'onetable:1.1.0' indexes <code>object</code> Hash of indexes used by the table. models <code>object</code> Hash of model entities describing the model keys, indexes and attributes. params <code>object</code> Hash of properties controlling how data is stored in the table. version <code>string</code> A SemVer compatible version string. <p>The <code>format</code> property specifies the schema format version and must be set to <code>onetable:1.1.0</code>.</p> <p>The <code>indexes</code> property specifies the key structure for the primary, local and secondary indexes.</p> <p>The <code>models</code> property contains one or more models with attribute field descriptions. The models collections define the attribute names, types, mappings, validations and other properties.</p> <p>The <code>params</code> property defines additional parameters for table data formats.</p> <p>The <code>version</code> property defines a version for your DynamoDB model design. It must be a SemVer compatible version string. The version string is used by tools and consumers of the schema to understand compatibility constraints for the schema and stored data.</p>"},{"location":"api/table/schemas/modeling/#schema-models","title":"Schema Models","text":"<p>The schema defines a model for each application entity. For example:</p> <pre><code>{\nalbum: {\npk:     { type: String, value: '${_type}#${name}' },\nsk:     { type: String, value: '${_type}#' },\nname:   { type: String, required: true },\nsongs:  { type: Number },\n},\nartist: {\npk:     { type: String, value: '${_type}#${name}' },\nsk:     { type: String, value: '${_type}#' },\nname:   { type: String, required: true },\naddress: {\ntype: Object, schema: {\nstreet: { type: String },\ncity: { type: String },\nzip: { type: String },\n},\n},\n}\n}\n</code></pre> <p>The name of the entity model is the model map name (album and artist above).</p> <p>For each model, all the entity attributes are defined by specifying the attribute type, validations and other operational characteristics (uniqueness, IDs and templates).</p> <p>The valid types are: Array, Binary, Boolean, Buffer, Date, Number, Object, Set and String.</p> <p>OneTable will ensure that values are of the correct type before writing to the database. Where possible, values will be cast to their correct types. For example: 'false' will be cast to false for Boolean types and 1000 will be cast to '1000' for String types.</p> <p>These JavaScript types map onto the equivalent DynamoDB types. For Binary types, you can supply data values with the types: ArrayBuffer and Buffer.</p> <p>For Sets, you should set the schema type to Set and supply values as instances of the JavaScript Set type. DynamoDB supports sets with elements that are strings, numbers or binary data.</p> <p>OneTable will automatically add a <code>_type</code> attribute to each model that is set to the name of the model. However, you can explicitly define your type attribute in your model schema if you wish.</p> <p>The type field can be used in PK/SK value templates by using <code>${_type}</code>. You can change the name of the type field from <code>_type</code> by setting the <code>params.typeField</code> in the Table constructor.</p>"},{"location":"api/table/schemas/modeling/#nested-schemas","title":"Nested Schemas","text":"<p>For object attributes, you can define a nested schema for the object properties, as in the example above (repeated below).</p> <p>A nested schema uses the <code>schema</code> property to define a nested map of attributes.</p> <pre><code>    address: {\ntype: Object, schema: {\nstreet: { type: String },\ncity: { type: String },\nzip: { type: String },\n}\n}\n</code></pre> <p>To model an array, use the <code>items</code> property to model the array items. Using a default value for the array and items can be useful to avoid having to test for existance.</p> <pre><code>    addresses: {\ntype: Array, default: [], items: {\ntype: Object, default: {}, schema: {\nstreet: { type: String },\ncity: { type: String },\nzip: { type: String },\n}\n}\n}\n</code></pre>"},{"location":"api/table/schemas/models/","title":"Models","text":"<p>The <code>schema.models</code> property contains one or more models with attribute field descriptions. The models collections define the attribute names, types, mappings, validations and other properties. For example:</p> <pre><code>{\nalbum: {\npk:     { type: String, value: '${_type}#${name}' },\nsk:     { type: String, value: '${_type}#' },\nname:   { type: String, required: true },\nsongs:  { type: Number },\n},\nartist: {\npk:     { type: String, value: '${_type}#${name}' },\nsk:     { type: String, value: '${_type}#' },\nname:   { type: String, required: true },\naddresses: {\ntype: Array, default: [], items: {\ntype: Object, default: {}, schema: {\nstreet: { type: String },\ncity: { type: String },\nzip: { type: String },\n}\n}\n}\n}\n}\n</code></pre> <p>The name of the entity model is model map name (album and artist above).</p> <p>The valid types are: Array, Binary, Boolean, Buffer, Date, Number, Object, Set and String.</p> <p>OneTable will ensure that values are of the correct type before writing to the database. Where possible, values will be cast to their correct types. For example: 'false' will be cast to false for Boolean types and 1000 will be cast to '1000' for String types.</p> <p>These JavaScript types map onto the equivalent DynamoDB types. For Binary types, you can supply data values with the types: ArrayBuffer and Buffer.</p> <p>For Sets, you should set the schema type to Set and supply values as instances of the JavaScript Set type. DynamoDB supports sets with elements that are strings, numbers or binary data.</p> <p>OneTable will automatically add a <code>_type</code> attribute to each model that is set to the name of the model. However, you can explicitly define your type attribute in your model schema if you wish.</p> <p>The type field can be used in PK/SK value templates by using <code>${_type}</code>. You can change the name of the type field from <code>_type</code> by setting the <code>params.typeField</code> in the Table constructor.</p> <p>You can define nested arrays and objects using the <code>items</code> and <code>schema</code> properties.</p>"},{"location":"api/table/schemas/params/","title":"Params","text":"<p>The <code>schema.params</code> is a hash map of properties that control how data is stored. It may contain the following properties:</p> Property Type Description createdField <code>string</code> Name of the \"created\" timestamp attribute. Defaults to \"created\". hidden <code>boolean</code> Hide templated (value) attributes in Javascript properties. Default true. isoDates <code>boolean</code> Set to true to store dates as Javascript ISO strings vs epoch numerics. Default false. nulls <code>boolean</code> Store nulls in database attributes vs remove attributes set to null. Default false. separator <code>string</code> Define the field separator used in value templates. This is only used by OneTable for encoded fields, but is generally useful for tools to understand value templates. timestamps <code>boolean | string</code> Make \"created\" and \"updated\" timestamps in items. Set to true to create both. Set to 'create' for only \"created\" timestamp and set to \"update\" for only an \"updated\" timestamp. See below for more details. Also see: \"updatedField\" and \"createdField\" properties. Default false. typeField <code>string</code> Name of the \"type\" attribute. Default \"_type\". updatedField <code>string</code> Name of the \"updated\" timestamp attribute. Default \"updated\". <p>For example:</p> <pre><code>const MySchema = {\nparams: {\nisoDates: true,\nseparator: '#',\ntimestamps: true,\n}\n}\n</code></pre>"},{"location":"api/table/schemas/params/#timestamps","title":"Timestamps","text":"<p>Created and updated timestamps can be automatically added to items. If the schema timestamps param is set to true, a <code>created</code> and <code>updated</code> date timestamp will be added to items during create or update API calls. </p> <p>If using TypeScript, you should define the created and updated fields in your data model so that the returned items match your TypeScript definitions. If using JavaScript, it is optional if you wish to define them in your model.</p> <p>The name of the <code>created</code> and <code>updated</code> fields can be modified via the schema param <code>createdField</code> and <code>updatedField</code>.</p> <p>If you need to manually modify a created or updated timestamp, you can disable automatic timestamps by setting the API <code>timestamps</code> param to false. For example:</p> <pre><code>props.updated = new Date('2023-02-26T23:23:14.752Z')\nawait User.update(props, {timestamps: false})\n</code></pre>"},{"location":"guides/overview/","title":"DynamoDB and Serverless Guides","text":"<p>Here is a collection of articles that can help you on your way with DynamoDB.</p> <p></p>"},{"location":"guides/overview/#dynamodb-articles","title":"DynamoDB Articles","text":"DynamoDB Topic Link Intro to DynamoDB https://www.sensedeep.com/blog/posts/2021/dynamodb-onetable-tour.html Data Modeling for DynamoDB https://www.sensedeep.com/blog/posts/2021/dynamodb-singletable-design.html The What and Why of Single Table Design https://www.alexdebrie.com/posts/dynamodb-single-table/ DynamoDB with OneTable Schemas https://www.sensedeep.com/blog/posts/2021/dynamodb-schemas.html DynamoDB OneTable API Overview https://www.sensedeep.com/blog/posts/2021/dynamodb-onetable-tour.html DynamoDB Checklist https://www.sensedeep.com/blog/posts/2021/dynamodb-checklist.html DynamoDB with TypeScript https://www.sensedeep.com/blog/posts/2021/dynamodb-typescript.html DynamoDB Sparse GSIs https://www.sensedeep.com/blog/posts/2021/sparse-gsi-indexes.html DynamoDB Attribute Packing https://www.sensedeep.com/blog/posts/2021/attribute-packing.html Evolving DynamoDB Designs https://www.sensedeep.com/blog/posts/2021/evolving-dynamodb-designs.html SenseDeep Migration Manager https://www.sensedeep.com/blog/posts/series/dynamodb-studio/migration-manager.html SenseDeep DynamoDB Studio https://www.sensedeep.com/blog/posts/stories/dynamodb-studio.html SenseDeep DynamoDB Quick Tour https://www.sensedeep.com/blog/posts/product/dynamodb-tour.html"},{"location":"guides/overview/#serverless-articles","title":"Serverless Articles","text":"Serverless Topic Link How to Debug Serverless Apps https://www.sensedeep.com/blog/posts/stories/how-to-debug-serverless-apps.html How to invoke HTTP without Waiting from Lambda https://www.sensedeep.com/blog/posts/stories/lambda-fast-http.html Fast Logging with Lambda https://www.sensedeep.com/blog/posts/senselogs/serverless-logging.html"},{"location":"services/consulting/","title":"DynamoDB Consulting","text":"<p>If you need help with your DynamoDB design, modeling or implementation, SenseDeep can help.</p> <p>As the authors of OneTable, we have deep experience in every aspect of Amazon DynamoDB for projects large and small.</p> <p>To discuss your project and how we can help, please contact us at SenseDeep Services.</p>"},{"location":"services/consulting/#design-review","title":"Design Review","text":"<p>Whether you have a new DynamoDB project or an existing production site, a review of your DynamoDB design can spot and fix potential issues. We can review your table structure, indexes, data modeling, key design, data access patterns and operational practices.</p>"},{"location":"services/consulting/#design-changes-and-migrations","title":"Design Changes and Migrations","text":"<p>Design changes to your DynamoDB table and data migrations without down-time or data risk are difficult to achieve. We have extensive experience evolving live production sites to upgrade DynamoDB tables without impacting user access or data.</p> <p>If you have a pending migration, we can be able to help.</p>"},{"location":"services/consulting/#data-modeling-and-mapping","title":"Data Modeling and Mapping","text":"<p>If you are starting out and need guidance with your single-table data model, we can help using proven single-table design patterns and techniques.</p>"},{"location":"services/consulting/#performance-and-cost-optimization-and-tuning","title":"Performance and Cost Optimization and Tuning","text":"<p>We created the OneTable metrics and DynamoDB Metrics libraries to address the serious lack of good DynamoDB performance monitoring tools. We can help tune your DynamoDB service to lower cost and improve performance and scale.</p>"},{"location":"services/consulting/#contact","title":"Contact","text":"<p>To discuss your project, please contact us at SenseDeep Services.</p>"},{"location":"start/configure/","title":"Configuring","text":""},{"location":"start/configure/#aws-sdk-v3","title":"AWS SDK V3","text":"<p>If you are using the AWS SDK V3, import the AWS V3 <code>DynamoDBClient</code> class. Then create a <code>DynamoDBClient</code> instance.</p> <pre><code>import {DynamoDBClient} from '@aws-sdk/client-dynamodb'\nconst client = new DynamoDBClient(params)\n</code></pre>"},{"location":"start/configure/#aws-sdk-v2","title":"AWS SDK V2","text":"<p>If you are using the legacy AWS SDK V2, import the AWS V2 SDK <code>DynamoDB</code> class and create a <code>DocumentClient</code> instance.</p> <pre><code>import DynamoDB from 'aws-sdk/clients/dynamodb'\nconst client = new DynamoDB.DocumentClient(params)\n</code></pre> <p>Note: you can use the Table.setClient API to defer setting the client or replace the client at any time.</p>"},{"location":"start/contact/","title":"Contact","text":"<p>You can contact me (Michael O'Brien) on Twitter at: @mobstream, or email and read my Blog.</p>"},{"location":"start/contact/#sensedeep-dynamodb-services","title":"SenseDeep DynamoDB Services","text":"<p>If you would like help with your DynamoDB designs or implementation, we offer a range of consulting services for DynamoDB and Serverless. See SenseDeep Services for more details.</p>"},{"location":"start/contact/#sensedeep-serverless-developer-studio","title":"SenseDeep Serverless Developer Studio","text":"<p>The SenseDeep Serverless Developer Studio SenseDeep has an integrated suite of DynamoDB tools with a single-table aware data browser, single-table designer, provisioning planner, migration manager and metrics.</p>"},{"location":"start/contribute/","title":"Contribute","text":"<p>Join the active community using OneTable on our GitHub Discussion Hub.</p> <p>All discussion, feedback, code contributions and bug reports are very welcome.</p> <ul> <li>Discussions</li> <li>Issues</li> <li>Pull Requests</li> </ul>"},{"location":"start/features/","title":"Features","text":"<ul> <li>Schema supported one-table access to DynamoDB APIs.</li> <li>Efficient storage and access of multiple entities in a single DynamoDB table.</li> <li>High level API with type marshaling, validations, and extended query capability for get/delete/update operations.</li> <li>Bidirectional conversion of DynamoDB types to Javascript types.</li> <li>Generation of Conditional, Filter, Key and Update expressions.</li> <li>Schema item definitions for attribute types, default values, enums, unique attributes and validations.</li> <li>Option to invoke DynamoDB or simply generate API parameters.</li> <li>Powerful field level validations with \"required\" and \"unique\" attributes.</li> <li>Easy parameterization of filter and conditional queries.</li> <li>Detailed metrics by Table, Tenant, Source, Index, Model and Operation.</li> <li>Multi-page response aggregation.</li> <li>Compound and templated key management.</li> <li>Attribute mapping and packing.</li> <li>Support for sparse GSIs that project keys and overloaded attributes.</li> <li>Encrypted fields.</li> <li>CreateTable, DeleteTable table and index admin operations.</li> <li>Support for Batch, Transactions, GSI, LSI indexes.</li> <li>Intercept hooks to modify DynamoDB requests and responses.</li> <li>Controllable logging to see exact parameter, data and responses.</li> <li>Simple and easy to read source.</li> <li>Integrated statistics.</li> <li>Safety options to prevent \"rm -fr *\".</li> <li>No module dependencies.</li> <li>Support for the AWS SDK v3.</li> <li>TypeScript type inference from schema for full type validation on APIs, parameters, returns, and entities and attributes.</li> <li>Migrations support via OneTable Migrate and OneTable CLI.</li> <li>Graphical monitoring of single-table performance via SenseDeep.</li> </ul>"},{"location":"start/install/","title":"Installing","text":"<p>To install OneTable, use <code>npm</code>.</p> <pre><code>npm i dynamodb-onetable\n</code></pre>"},{"location":"start/modeling/","title":"Data Modeling","text":"<p>OneTable models your application entities via a OneTable schema that defines models for your entities and specifies how data items will indexed in your database.</p> <p>Schemas are defined in JSON and are passed to your OneTable Table constructor at initialization time.</p> <p>Schemas can also be created and managed by tools such as the SenseDeep DynamoDB Studio. When SenseDeep authors a schema, it will save the schema to your DynamoDB table and will generate the JSON for use by the OneTable Table constructor.</p> <pre><code>const MySchema = {\nformat: 'onetable:1.1.0',\nversion: '0.0.1',\nindexes: {\nprimary: { hash: 'pk', sort: 'sk' },\ngs1:     { hash: 'gs1pk', sort: 'gs1sk', follow: true },\nls1:     { sort: 'id', type: 'local' },\n},\nmodels: {\nAccount: {\npk:          { type: String, value: 'account#${name}' },\nsk:          { type: String, value: 'account#' },\nid:          { type: String, generate: 'ulid', validate: /^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$/i },\nname:        { type: String, required: true },\nstatus:      { type: String, default: 'active' },\nzip:         { type: String },\n},\nUser: {\npk:          { type: String, value: 'account#${accountName}' },\nsk:          { type: String, value: 'user#${email}', validate: EmailRegExp },\nid:          { type: String, required: true },\naccountName: { type: String, required: true },\nemail:       { type: String, required: true, encode: 'sk' },\nfirstName:   { type: String, required: true },\nlastName:    { type: String, required: true },\nusername:    { type: String, required: true },\nrole:        { type: String, enum: ['user', 'admin'], required: true, default: 'user' },\nbalance:     { type: Number, default: 0 },\ngs1pk:       { type: String, value: 'user-email#${email}' },\ngs1sk:       { type: String, value: 'user#' },\n}\n},\nparams: {\n'isoDates': true,\n'separator': '#',\n'timestamps': true,\n},\n}\n</code></pre> <p>The OneTable schema is passed to your table constructor via the <code>schema</code> property.</p> <pre><code>const table = new Table({\nclient: client,\nname: 'MyTable',\nschema: MySchema,\n})\n</code></pre> <p>See the API Schemas for full details about creating your schema.</p>"},{"location":"start/quick-tour/","title":"Quick Tour","text":"<p>OneTable is the most evolved API for DynamoDB. It provides a high-level, elegant dry syntax while still enabling full access to DynamoDB API.</p> <p>OneTable works with AWS V2 and V3 SDKs for JavaScript and TypeScript. For TypeScript, OneTable will create fully typed entities from your data schemas automatically.</p> <p>To see OneTable in action, take this quick tour of OneTable which demonstrates importing, configuring and basic operation of OneTable.</p>"},{"location":"start/quick-tour/#import-onetable","title":"Import OneTable","text":"<p>To start, import the OneTable library.</p> <pre><code>import {Table} from 'dynamodb-onetable'\n</code></pre>"},{"location":"start/quick-tour/#import-the-aws-sdk","title":"Import the AWS SDK","text":"<p>If you are not using ES modules or TypeScript, use <code>require</code> to import the libraries.</p> <p>If you are using the AWS SDK V3, import the AWS V3 <code>DynamoDBClient</code> class. Then create a <code>DynamoDBClient</code> instance.</p> <pre><code>import {DynamoDBClient} from '@aws-sdk/client-dynamodb'\nconst client = new DynamoDBClient(params)\n</code></pre> <p>If you are using the legacy AWS SDK V2, import the AWS <code>DynamoDB</code> class and create a <code>DocumentClient</code> instance.</p> <pre><code>import DynamoDB from 'aws-sdk/clients/dynamodb'\nconst client = new DynamoDB.DocumentClient(params)\n</code></pre> <p>Note: you can use the Table.setClient API to defer setting the client or replace the client at any time.</p>"},{"location":"start/quick-tour/#configure-the-table-class","title":"Configure the Table Class","text":"<p>Initialize your OneTable <code>Table</code> instance and define your application entities via a OneTable schema.</p> <pre><code>const table = new Table({\nclient: client,\nname: 'MyTable',\nschema: MySchema,\n})\n</code></pre>"},{"location":"start/quick-tour/#data-modeling","title":"Data Modeling","text":"<p>OneTable models your application entities via a OneTable schema.</p> <p>The schema defines your entities and their attributes and how they will be stored in your DynamoDB table. The schema also defines the table indexes. Here is a sample schema:</p> <pre><code>const MySchema = {\nformat: 'onetable:1.1.0',\nversion: '0.0.1',\nindexes: {\nprimary: { hash: 'pk', sort: 'sk' },\ngs1:     { hash: 'gs1pk', sort: 'gs1sk', follow: true },\nls1:     { sort: 'id', type: 'local' },\n},\nmodels: {\nAccount: {\npk:          { type: String, value: 'account#${id}' },\nsk:          { type: String, value: 'account#' },\nid:          { type: String, generate: 'ulid', validate: /^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$/i },\nname:        { type: String, required: true },\nstatus:      { type: String, default: 'active' },\nzip:         { type: String },\n},\nUser: {\npk:          { type: String, value: 'account#${accountName}' },\nsk:          { type: String, value: 'user#${email}', validate: EmailRegExp },\nid:          { type: String, required: true },\naccountName: { type: String, required: true, encode: 'pk' },\nemail:       { type: String, required: true, encode: 'sk' },\nfirstName:   { type: String, required: true },\nlastName:    { type: String, required: true },\nusername:    { type: String, required: true },\nrole:        { type: String, enum: ['user', 'admin'], required: true, default: 'user' },\nbalance:     { type: Number, default: 0 },\ngs1pk:       { type: String, value: 'user-email#${email}' },\ngs1sk:       { type: String, value: 'user#' },\n}\n},\nparams: {\n'isoDates': true,\n'separator': '#',\n'timestamps': true,\n},\n}\n</code></pre> <p>For each model, you define the entity attributes and their type and other properties.</p>"},{"location":"start/quick-tour/#get-a-model","title":"Get a Model","text":"<p>To interact with DynamoDB, get a model for the application entity.</p> <pre><code>const model = table.getModel('Account')\n</code></pre> <p>If using TypeScript, see TypeScript Tour.</p>"},{"location":"start/quick-tour/#create-an-item","title":"Create an Item","text":"<p>To create <pre><code>let account = await Account.create({\nid: '8e7bbe6a-4afc-4117-9218-67081afc935b',\nname: 'Acme Airplanes',\n})\n</code></pre></p> <p>This will write the following to DynamoDB: <pre><code>{\npk:         'account:8e7bbe6a-4afc-4117-9218-67081afc935b',\nsk:         'account:98034',\nid:         '8e7bbe6a-4afc-4117-9218-67081afc935b',\nname:       'Acme Airplanes',\nstatus:     'active',\nzip:        '98034',\ncreated:    1610347305510,\nupdated:    1610347305510,\n}\n</code></pre></p>"},{"location":"start/quick-tour/#get-an-item","title":"Get an Item","text":"<pre><code>let account = await Account.get({\nid: '8e7bbe6a-4afc-4117-9218-67081afc935b',\n})\n</code></pre> <p>which will return:</p> <pre><code>{\nid:       '8e7bbe6a-4afc-4117-9218-67081afc935b',\nname:     'Acme Airplanes',\nstatus:   'active',\nzip:      '98034',\n}\n</code></pre>"},{"location":"start/quick-tour/#use-a-secondary-index","title":"Use a Secondary Index:","text":"<pre><code>let user = await User.get({email: 'user@example.com'}, {index: 'gs1'})\n</code></pre>"},{"location":"start/quick-tour/#find-items","title":"Find Items","text":"<p>To find a set of items:</p> <pre><code>let users = await User.find({accountId: account.id})\nlet adminUsers = await User.find({accountId: account.id, role: 'admin'})\nlet users = await User.find({accountId: account.id}, {\nwhere: '${balance} &gt; {100.00}'\n})\n//  Get a count of matching users without returning the actual items\nlet users = await User.find({accountId: account.id, role: 'admin'}, {count: true})\nlet count = users.count\n</code></pre>"},{"location":"start/quick-tour/#update-an-item","title":"Update an Item","text":"<pre><code>await User.update({id: userId, balance: 50})\nawait User.update({id: userId}, {add: {balance: 10.00}})\nawait User.update({id: userId}, {set: {status: '{active}'}})\nawait User.update({id: userId}, {push: {tasks: 'Learn DynamoDB'}})\n</code></pre>"},{"location":"start/quick-tour/#transactional-updates","title":"Transactional Updates","text":"<pre><code>let transaction = {}\nawait Account.update({id: account.id, status: 'active'}, {transaction})\nawait User.update({id: user.id, role: 'user'}, {transaction})\nawait table.transact('write', transaction)\n</code></pre>"},{"location":"start/quick-tour/#more","title":"More","text":"<p>There is so much more including</p> <ul> <li>TypeScript type checking of APIs and schema data</li> <li>Validations</li> <li>Support for required and unique attributes</li> <li>Batch updates</li> <li>Automatic extra encryption for sensitive attributes</li> <li>Detailed Metrics</li> <li>Multi-page response aggregation</li> <li>Create and manage tables</li> <li>Database migrations</li> <li>Integrated logging of requests and responses</li> </ul>"},{"location":"start/references/","title":"References","text":"<ul> <li>OneTable Samples</li> <li>OneTable Schema Specification</li> <li>OneTable Tests</li> <li>SenseDeep Blog</li> <li>DynamoDB Checklist</li> <li>DynamoDB Articles</li> <li>DynamoDB Book</li> <li>Alex DeBrie Best Practices Video</li> <li>DocumentClient SDK Reference</li> <li>DynamoDB Guide</li> <li>Best Practices for DynamoDB</li> </ul>"},{"location":"start/samples/","title":"Samples","text":"<p>To get you going quickly, try out the working samples in the OneTable repository at:</p> <ul> <li>OneTable Overview Sample \u2014 A quick tour through OneTable.</li> <li>OneTable CRUD Sample \u2014 Basic CRUD.</li> <li>OneTable TypeScript Sample</li> <li>OneTable Migrate Sample \u2014 how to use OneTable Migrate.</li> <li>OneTable Packed Attributes Sample \u2014 How to use packed attributes.</li> <li>OneTable SenseDeep Sample \u2014 How to access SenseDeep log data.</li> <li>All OneTable Samples</li> </ul>"},{"location":"start/typescript/","title":"Typescript","text":"<p>OneTable provides TypeScript type declaration files so that OneTable APIs, requests and responses can be fully type checked.</p> <p>Using the magic of TypeScript dynamic typing, OneTable automatically converts your OneTable schema into fully typed generic Model APIs. This way, OneTable creates type declarations for your table entities and attributes so that TypeScript will catch any invalid entity or entity attribute references.</p> <p>For example:</p> <pre><code>import {Entity, Model, Table} from 'dynamodb-onetable'\nconst MySchema = {\n...\nmodels: {\nAccount: {\npk:    { type: String, value: 'account#${name}' },\nname:  { type: String },\n}\n} as const     // Required for TypeScript\n}\n</code></pre> <p>When defining your OneTable schema for Typescript, you must use type objects (String, Date, Number etc) as the value for your <code>type</code> properties. When using Javascript, you can also use string values ('string', 'date', 'number'), but for Typescript, this will prevent the Typescript dynamic typing from working.</p> <p>You also need to append the <code>as const</code> to the end of your \"models\" in the schema.</p>"},{"location":"start/typescript/#typed-application-models","title":"Typed Application Models","text":"<p>Using the <code>Entity</code> generic type, you can create types for your schema models.</p> <pre><code>type Account = Entity&lt;typeof MySchema.models.Account&gt;\n</code></pre> <p>With these types, you can declare typed variables.</p> <pre><code>let account: Account = {\nname: 'Coyote',        //  OK\nunknown: 42,           //  Error\n}\n</code></pre> <p>Similarly you can use a typed version of <code>getModel</code> to retrieve a typed Model to interact with OneTable.</p> <pre><code>//  Get an Account access model\nlet AccountModel: Model&lt;Account&gt; = table.getModel&lt;Account&gt;('Account')\nlet account = await AccountModel.create({\nname: 'Acme',               //  OK\nunknown: 42,                //  Error\n})\naccount.name = 'Coyote'         //  OK\naccount.unknown = 42            //  Error\n</code></pre>"},{"location":"start/typescript/#type-enforcement","title":"Type Enforcement","text":"<p>Attributes that are defined in the schema with the \"required\" property will be mandatory in your Entity types. Those without the \"required\" property will be optional.</p> <p>The Model.create() API can take a subset of the defined properties, provided that all required properties are present. TypeScript will enforce this.</p> <p>The Model.update() API can take a subset of the defined properties. Required properties are not required for update unless they are part of the PK/SK value templates.</p> <p>The Model.find() and Model.remove() API can take a subset of defined properties.</p>"},{"location":"start/why-onetable/","title":"Why OneTable?","text":"<p>DynamoDB is a great NoSQL database that comes with a learning curve. Folks migrating from SQL often have a hard time adjusting to the NoSQL paradigm and especially to DynamoDB which offers exceptional scalability but with a fairly low-level API.</p> <p>The standard DynamoDB API requires a lot of boiler-plate syntax and expressions. This is tedious to use and can unfortunately can be error prone at times. I doubt that creating complex attribute type, key, filter, condition and update expressions are anyone's idea of a good time.</p> <p>Net/Net: it is not easy to write terse, clear, robust Dynamo code for one-table patterns.</p> <p>Our goal with OneTable for DynamoDB was to keep all the good parts of DynamoDB and to remove the tedium and provide a more natural, \"JavaScripty / TypeScripty\" way to interact with DynamoDB without obscuring any of the power of DynamoDB itself.</p> <p>For single-table designs, OneTable makes the job of managing single-table patterns a joy. OneTable easily manages multiple application entities, data integrity, compound keys, secondary indexes, validations and unique attributes. OneTable defines a higher level API so that you can concentrate on your application logic and let OneTable look after the mechanics of storing the data in your single table.</p>"}]}